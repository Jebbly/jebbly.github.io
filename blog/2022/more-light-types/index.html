<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Adding More Light Types | Jeffrey Liu </title> <meta name="author" content="Jeffrey Liu"> <meta name="description" content="How different light types in Blender are used in the many lights sampling algorithm."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/site_icon.jpg?81c0048f0ca63c3f56bd57b1992ac3e2"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jebbly.github.io/blog/2022/more-light-types/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Jeffrey</span> Liu </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog posts </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">search <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Adding More Light Types</h1> <p class="post-meta"> Created in July 02, 2022 </p> <p class="post-tags"> <a href="/blog/2022"> <i class="fa-solid fa-calendar fa-sm"></i> 2022 </a>   ·   <a href="/blog/tag/path-tracing"> <i class="fa-solid fa-hashtag fa-sm"></i> path-tracing</a>   ·   <a href="/blog/category/gsoc-2022"> <i class="fa-solid fa-tag fa-sm"></i> gsoc-2022</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>In this post, I’ll be discussing how the different light types in Blender were incorporated into the many lights sampling algorithm. Some of these lights could be immediately plugged in to the existing work, but others needed some redesigning of the logic.</p> <h2 id="different-light-types">Different Light Types</h2> <p>Blender has a variety of light types that all need to be supported by the algorithm. This includes:</p> <ul> <li>Point, Spot, and Area Lights</li> <li>Emissive Triangles</li> <li>Distant and Background Lights</li> </ul> <p>Each of these bullet points have slightly different places in the code, which I’ll elaborate on below.</p> <h3 id="point-spot-and-area-lights">Point, Spot, and Area Lights</h3> <p>Once we have point lights working, it’s really immediate to also incorporate spot and area lights. All we have to do is update our light tree construction to account for their different bounding information (actually, I had to update some of the traversal code as well, but the next section will explain why I don’t discuss it here). The first thing to get out of the way is that the energy calculations for these light types are exactly the same. Next, this is the different bounding cone information for each light type:</p> <table> <thead> <tr> <th style="text-align: center">Light Type</th> <th style="text-align: center">Axis</th> <th style="text-align: center">\(\theta_o\)</th> <th style="text-align: center">\(\theta_e\)</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">Point</td> <td style="text-align: center">Arbitrary</td> <td style="text-align: center">\(\pi\)</td> <td style="text-align: center">\(\pi / 2\)</td> </tr> <tr> <td style="text-align: center">Spot</td> <td style="text-align: center">Spotlight Direction</td> <td style="text-align: center">0</td> <td style="text-align: center">Spotlight Angle</td> </tr> <tr> <td style="text-align: center">Area</td> <td style="text-align: center">Normal Axis</td> <td style="text-align: center">0</td> <td style="text-align: center">\(\pi / 2\)</td> </tr> </tbody> </table> <p>This makes sense because point lights don’t have a defined orientation direction while spot lights and area lights do. Implementing this in the code is also very straightforward using a bunch of conditionals.</p> <p>The bounding box information for these lights is only slightly more interesting, and there are only a few things to note. The point lights and spot lights have an associated <code class="language-plaintext highlighter-rouge">size</code>. What this means is that they can actually emit light from a radius of that size, so our bounding box needs to account for that radius. On the other hand, area lights can either be a disk or a rectangle, and thus have 2 dimensions to them. They have the members <code class="language-plaintext highlighter-rouge">axisu</code> and <code class="language-plaintext highlighter-rouge">axisv</code> which correspond to the orientation of those dimensions, as well as a <code class="language-plaintext highlighter-rouge">sizeu</code> and <code class="language-plaintext highlighter-rouge">sizev</code> which dictate how far along the axis it goes. Knowing this, the code is also relatively straightforward:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\scene\light_tree.cpp</span>
<span class="n">Light</span> <span class="o">*</span><span class="n">lamp</span> <span class="o">=</span> <span class="n">scene</span><span class="o">-&gt;</span><span class="n">lights</span><span class="p">[</span><span class="n">lamp_id</span><span class="p">];</span>
<span class="n">LightType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">get_light_type</span><span class="p">();</span>
<span class="k">const</span> <span class="n">float3</span> <span class="n">center</span> <span class="o">=</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">get_co</span><span class="p">();</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">size</span> <span class="o">=</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">get_size</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">LIGHT_POINT</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="n">LIGHT_SPOT</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* Point and spot lights can emit light from any point within its radius. */</span>
  <span class="k">const</span> <span class="n">float3</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">make_float3</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
  <span class="n">bbox</span><span class="p">.</span><span class="n">grow</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">radius</span><span class="p">);</span>
  <span class="n">bbox</span><span class="p">.</span><span class="n">grow</span><span class="p">(</span><span class="n">center</span> <span class="o">+</span> <span class="n">radius</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">LIGHT_AREA</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* For an area light, sizeu and sizev determine the 2 dimensions of the area light,
  * while axisu and axisv determine the orientation of the 2 dimensions.
  * We want to add all 4 corners to our bounding box. */</span>
  <span class="k">const</span> <span class="n">float3</span> <span class="n">half_extentu</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">get_sizeu</span><span class="p">()</span> <span class="o">*</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">get_axisu</span><span class="p">()</span> <span class="o">*</span> <span class="n">size</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">float3</span> <span class="n">half_extentv</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">get_sizev</span><span class="p">()</span> <span class="o">*</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">get_axisv</span><span class="p">()</span> <span class="o">*</span> <span class="n">size</span><span class="p">;</span>

  <span class="n">bbox</span><span class="p">.</span><span class="n">grow</span><span class="p">(</span><span class="n">center</span> <span class="o">+</span> <span class="n">half_extentu</span> <span class="o">+</span> <span class="n">half_extentv</span><span class="p">);</span>
  <span class="n">bbox</span><span class="p">.</span><span class="n">grow</span><span class="p">(</span><span class="n">center</span> <span class="o">+</span> <span class="n">half_extentu</span> <span class="o">-</span> <span class="n">half_extentv</span><span class="p">);</span>
  <span class="n">bbox</span><span class="p">.</span><span class="n">grow</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">half_extentu</span> <span class="o">+</span> <span class="n">half_extentv</span><span class="p">);</span>
  <span class="n">bbox</span><span class="p">.</span><span class="n">grow</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">half_extentu</span> <span class="o">-</span> <span class="n">half_extentv</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>In other parts of the Cycles code, the area light’s size is also scaled by the <code class="language-plaintext highlighter-rouge">size</code> member. I’ve always seen this factor equal to 1.0 in my own debugging, but I’ve left it here just to be safe.</p> <h3 id="emissive-triangles">Emissive Triangles</h3> <p>Even though I have a separate section for emissive triangles, I’m not really going to talk about the bounding information calculation (most of it was based off the past GSoC work anyways). Instead, this is going to be about how emissive triangles made me realize that some of the traversal logic needed to be reconsidered.</p> <p>Originally, I didn’t think there would be anything too special about triangle lights besides using the <code class="language-plaintext highlighter-rouge">prim_id</code> to distinguish them during light tree construction. However, when I got to traversal, I encountered a slight issue: although I could differentiate between a normal light source and an emissive triangle using the <code class="language-plaintext highlighter-rouge">light_distribution</code> array, I still didn’t have enough information to calculate the importance. It’s still possible to get the triangle’s vertices to manually calculate the bounding box min/max and also take the cross product to find the orientation axis. But then there’s also the issue of finding a proper energy estimate.</p> <p>In any case, doing all of this work during traversal seems like a huge performance issue. Additionally, this information is stuff that we can calculate at construction time and then store for the future. So using the same idea as the <code class="language-plaintext highlighter-rouge">device_vector&lt;KernelLightTreeNode&gt; light_tree_nodes</code>, there’s an array on the device containing the bounding information for each emitter:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\types.h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">KernelLightTreeEmitter</span> <span class="p">{</span>
  <span class="cm">/* Bounding box. */</span>
  <span class="kt">float</span> <span class="n">bounding_box_min</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">float</span> <span class="n">bounding_box_max</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

  <span class="cm">/* Bounding cone. */</span>
  <span class="kt">float</span> <span class="n">bounding_cone_axis</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">float</span> <span class="n">theta_o</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">theta_e</span><span class="p">;</span>

  <span class="cm">/* Energy. */</span>
  <span class="kt">float</span> <span class="n">energy</span><span class="p">;</span>

  <span class="cm">/* prim_id denotes the location in the lights or triangles array. */</span>
  <span class="kt">int</span> <span class="n">prim_id</span><span class="p">;</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">shader_flag</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">object_id</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">mesh_light</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
      <span class="kt">float</span> <span class="n">pad</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">size</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">lamp</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="cm">/* Padding. */</span>
  <span class="kt">int</span> <span class="n">pad1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">KernelLightTreeEmitter</span><span class="p">;</span>
<span class="n">static_assert_align</span><span class="p">(</span><span class="n">KernelLightTreeEmitter</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</code></pre></div></div> <p>The information under <code class="language-plaintext highlighter-rouge">prim_id</code> is the same as the information from the light distribution. However, by keeping it inside of this struct, we can remove our light tree kernel’s dependency on the light distribution. There still is a lot of overlap between this struct and the <code class="language-plaintext highlighter-rouge">KernelLightTreeNode</code> struct, but it works for now. Now after our construction has sorted all of the primitives in order, we can fill out the corresponding bounding information:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\scene\light.cpp</span>
<span class="n">KernelLightTreeEmitter</span> <span class="o">*</span><span class="n">light_tree_emitters</span> <span class="o">=</span> <span class="n">dscene</span><span class="o">-&gt;</span><span class="n">light_tree_emitters</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="n">num_distribution</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">num_distribution</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">LightTreePrimitive</span> <span class="o">&amp;</span><span class="n">prim</span> <span class="o">=</span> <span class="n">light_prims</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
  <span class="n">BoundBox</span> <span class="n">bbox</span> <span class="o">=</span> <span class="n">prim</span><span class="p">.</span><span class="n">calculate_bbox</span><span class="p">(</span><span class="n">scene</span><span class="p">);</span>
  <span class="n">OrientationBounds</span> <span class="n">bcone</span> <span class="o">=</span> <span class="n">prim</span><span class="p">.</span><span class="n">calculate_bcone</span><span class="p">(</span><span class="n">scene</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">energy</span> <span class="o">=</span> <span class="n">prim</span><span class="p">.</span><span class="n">calculate_energy</span><span class="p">(</span><span class="n">scene</span><span class="p">);</span>

  <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">energy</span> <span class="o">=</span> <span class="n">energy</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">bounding_box_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">.</span><span class="n">min</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">bounding_box_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">.</span><span class="n">max</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">bounding_cone_axis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bcone</span><span class="p">.</span><span class="n">axis</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">theta_o</span> <span class="o">=</span> <span class="n">bcone</span><span class="p">.</span><span class="n">theta_o</span><span class="p">;</span>
  <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">theta_e</span> <span class="o">=</span> <span class="n">bcone</span><span class="p">.</span><span class="n">theta_e</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">prim</span><span class="p">.</span><span class="n">prim_id</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">mesh_light</span><span class="p">.</span><span class="n">object_id</span> <span class="o">=</span> <span class="n">prim</span><span class="p">.</span><span class="n">object_id</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">shader_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// query shader flags (same as light distirbution)</span>
    <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">mesh_light</span><span class="p">.</span><span class="n">shader_flag</span> <span class="o">=</span> <span class="n">shader_flag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">Light</span> <span class="o">*</span><span class="n">lamp</span> <span class="o">=</span> <span class="n">scene</span><span class="o">-&gt;</span><span class="n">lights</span><span class="p">[</span><span class="n">prim</span><span class="p">.</span><span class="n">lamp_id</span><span class="p">];</span>
    <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">lamp</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">lamp</span><span class="p">.</span><span class="n">pad</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">dscene</span><span class="o">-&gt;</span><span class="n">light_tree_emitters</span><span class="p">.</span><span class="n">copy_to_device</span><span class="p">();</span>
</code></pre></div></div> <p>The advantage of this approach is that all of the decision making is happening at construction time. During traversal, we don’t need any conditionals to handle a different construction for each type of light. We just trust that all the information has been calculated correctly beforehand and then directly plug it into our formula.</p> <p>The last thing to do is to adjust the triangle sampling PDF. If you recall in my last post, I mentioned that the light distribution will pre-calculate some of the PDF. For example, for light sources, it knows that it’ll be sampling uniformly over light samples, so it sets</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\scene\light.cpp</span>
<span class="n">kintegrator</span><span class="o">-&gt;</span><span class="n">pdf_lights</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">num_lights</span><span class="p">;</span>
</code></pre></div></div> <p>On the other hand, the light distribution samples triangles relative to their total area. This is something that varies per-triangle, so the best that can be done is to pre-compute <code class="language-plaintext highlighter-rouge">kintegrator-&gt;pdf_triangles</code> as <code class="language-plaintext highlighter-rouge">1.0f / trianglearea</code>. Then the contributing PDf is calculated during <code class="language-plaintext highlighter-rouge">triangle_light_sample()</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light.h</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">pdf</span> <span class="o">=</span> <span class="n">area</span> <span class="o">*</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">pdf_triangles</span><span class="p">;</span>
</code></pre></div></div> <p>We’ll also be using <code class="language-plaintext highlighter-rouge">triangle_light_sample()</code>, but that’s not going to be the PDF of our sampling method. Instead, we set <code class="language-plaintext highlighter-rouge">kintegrator-&gt;pdf_triangles</code> and then divide <code class="language-plaintext highlighter-rouge">ls-&gt;pdf</code> by the triangle’s area to counteract the multiplication done inside of the function. This essentially converts the pre-computed PDF to <code class="language-plaintext highlighter-rouge">1.0f</code>, so now we’re free to control the PDF appropriately.</p> <h3 id="distant-and-background-lights">Distant and Background Lights</h3> <p>The reason why distant lights and background lights need to be handled separately is because the light tree is inherently location-based. Since these lights can be considered infinitely far away, we can’t really construct a bounding box or anything to make them part of the light tree. The original method we wanted to implement was to first pick a light from a light tree and another light from the distant/background lights, and then choose one of the two after weighing their importances. The idea would be that having 2 specific lights would be more specific.</p> <p>However, halfway through implementing this, I discovered that this would actually be pretty complicated. This is because we not only need to calculate the probability of selecting the light in order to scale our PDF accordingly. Now suppose we select one object from \(A = \{A_1, A_2\}\) and one object from \(B = \{B_1, B_2\}\). Then we put our two selected objects into a new group \(C\) and select one out of the two. For the sake of shorter notation, let \(O_{i_N}\) denote the probability of selecting object \(O_i\) from group \(N\). Now the probability of ending up with \(A_1\) as our final selection would be:</p> \[\mathbb{P}(A_{1_C}) = \mathbb{P}(A_{1_C} | A_{1_A} \cap B_{1_B}) \cdot \mathbb{P}(A_{1_A} \cap B_{1_B}) + \mathbb{P}(A_{1_C} | A_{1_A} \cap B_{2_B}) \cdot \mathbb{P}(A_{1_A} \cap B_{2_B})\] <p>Technically there are a few more terms (cases where \(A_2\) is selected from group \(A\)) but we can ignore them because they’re all equal to \(0\). The general idea is that to find the actual probability, we’d have to partition the probabilities into cases. So in this case, the true probability of selecting \(A_1\) is the probability of selecting it when \(C = \{A_1, B_1\}\) plus the probability of selecting it when \(C = \{A_1, B_2\}\). In code, we’d be able to naturally find the value of a single one of these terms, but we’d have to do a lot of extra computation to find the others.</p> <p>The next best thing we can do is first decide whether we want to sample from the light tree or to sample from the distant lights. For now, the easiest way to do this is by examining their relative energies. The advantage to this approach is that we can pre-compute both of these during construction time, but in the future, we may want to introduce an appropriate importance heuristic to decide between the two. Here, <code class="language-plaintext highlighter-rouge">pdf_light_tree</code> is calculated as the relative energy of the light tree compared to the total energy involved:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light_tree.h</span>
<span class="kt">float</span> <span class="n">tree_u</span> <span class="o">=</span> <span class="n">path_state_rng_1D</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">rng_state</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">tree_u</span> <span class="o">&lt;</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">pdf_light_tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pdf_factor</span> <span class="o">*=</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">pdf_light_tree</span><span class="p">;</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">light_tree_sample</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">(</span>
      <span class="n">kg</span><span class="p">,</span> <span class="n">rng_state</span><span class="p">,</span> <span class="n">randu</span><span class="p">,</span> <span class="n">randv</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">bounce</span><span class="p">,</span> <span class="n">path_flag</span><span class="p">,</span> <span class="n">ls</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdf_factor</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="n">pdf_factor</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">pdf_light_tree</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">light_tree_sample_distant_lights</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">(</span>
      <span class="n">kg</span><span class="p">,</span> <span class="n">rng_state</span><span class="p">,</span> <span class="n">randu</span><span class="p">,</span> <span class="n">randv</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">bounce</span><span class="p">,</span> <span class="n">path_flag</span><span class="p">,</span> <span class="n">ls</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdf_factor</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>The downside to this approach is that we’ll have to perform a linear scan if we want to sample from the distant lights group. Realistically though, or at least from my perpective, most scenes shouldn’t have that many distant lights. Furthermore, we can also compute importance heuristics if we choose to sample from the distant light group, so we can make more informed decisions about which light to sample.</p> <p>For now, <code class="language-plaintext highlighter-rouge">light_tree_distant_light_importance()</code> only returns the energy of the given distant light:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light_tree.h</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">num_distant_lights</span> <span class="o">=</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distant_lights</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">total_importance</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_distant_lights</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">total_importance</span> <span class="o">+=</span> <span class="n">light_tree_distant_light_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">inv_total_importance</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">total_importance</span><span class="p">;</span>

<span class="kt">float</span> <span class="n">light_cdf</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">distant_u</span> <span class="o">=</span> <span class="n">path_state_rng_1D</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">rng_state</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_distant_lights</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">float</span> <span class="n">light_pdf</span> <span class="o">=</span> <span class="n">light_tree_distant_light_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span>
                          <span class="n">inv_total_importance</span><span class="p">;</span>
  <span class="n">light_cdf</span> <span class="o">+=</span> <span class="n">light_pdf</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">distant_u</span> <span class="o">&lt;</span> <span class="n">light_cdf</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">pdf_factor</span> <span class="o">*=</span> <span class="n">light_pdf</span><span class="p">;</span>
    <span class="n">ccl_global</span> <span class="k">const</span> <span class="n">KernelLightTreeDistantEmitter</span> <span class="o">*</span><span class="n">kdistant</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span>
        <span class="n">light_tree_distant_group</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">lamp</span> <span class="o">=</span> <span class="o">-</span><span class="n">kdistant</span><span class="o">-&gt;</span><span class="n">prim_id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">light_select_reached_max_bounces</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">lamp</span><span class="p">,</span> <span class="n">bounce</span><span class="p">)))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">light_sample</span><span class="o">&lt;</span><span class="n">in_volume_segment</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">lamp</span><span class="p">,</span> <span class="n">randu</span><span class="p">,</span> <span class="n">randv</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">path_flag</span><span class="p">,</span> <span class="n">ls</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is bound to change as we come up with better heuristics in the future.</p> <h2 id="closing-thoughts">Closing Thoughts</h2> <p>Thanks to the heavy debugging from the work with point lights, most of the math was pretty much working from the get-go. However, there’s still a lot of optimizations to the heuristics that can (and will) be made. My main concern at the moment is that these heuristics don’t take visibility into consideration, which can really hurt the sampling in extreme cases. For example in one case, we could be placing high importance on one group of lights and dedicating a lot of samples towards them, without realizing that they’re actually all occluded! We’ll have to have another discussion for this in the future, but one solution that comes to mind is to also randomly select between using the light tree sampling and using the default light distribution sampling.</p> <p>Secondly, I also realized that there are 3 additional functions to update, which are used when Cycles performs indirect light samples (I’ll be making a separate post about this). These functions are basically used when Cycles is sampling based off of the BSDF and the sample intersects a light source, so we need to calculate what the direct lighting’s PDF would be in order to weight the multiple importance sampling. The functions are:</p> <ul> <li><code class="language-plaintext highlighter-rouge">background_light_pdf()</code></li> <li><code class="language-plaintext highlighter-rouge">triangle_light_pdf()</code></li> <li><code class="language-plaintext highlighter-rouge">light_sample_from_intersection()</code></li> </ul> <p>These functions are pretty self-explanatory, but it’ll be a little tricky to incorporate the light tree into them. More on that in the next post!</p> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Jeffrey Liu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: September 18, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-GB73T9E4G9"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-GB73T9E4G9");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-publications",title:"publications",description:"(* denotes equal contribution)",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"nav-blog-posts",title:"blog posts",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"post-reflecting-on-gsoc-2022",title:"Reflecting on GSoC 2022",description:"A three month late reflection on GSoC 2022.",section:"Posts",handler:()=>{window.location.href="/blog/2022/gsoc-conclusion/"}},{id:"post-weighted-reservoir-sampling-for-adaptive-splitting",title:"Weighted Reservoir Sampling for Adaptive Splitting",description:"The Cycles version of adaptive splitting.",section:"Posts",handler:()=>{window.location.href="/blog/2022/adaptive-splitting/"}},{id:"post-correcting-for-multiple-importance-sampling",title:"Correcting for Multiple Importance Sampling",description:"Fixes to the PDF calculations to adjust for the light tree sampling.",section:"Posts",handler:()=>{window.location.href="/blog/2022/light-tree-mis/"}},{id:"post-adding-more-light-types",title:"Adding More Light Types",description:"How different light types in Blender are used in the many lights sampling algorithm.",section:"Posts",handler:()=>{window.location.href="/blog/2022/more-light-types/"}},{id:"post-supporting-point-lights",title:"Supporting Point Lights",description:"A more detailed technical explanation of supporting the many lights algorithm for point lights in Blender.",section:"Posts",handler:()=>{window.location.href="/blog/2022/blender-point-lights/"}},{id:"post-motivating-many-lights-sampling-with-a-light-tree",title:"Motivating Many Lights Sampling with a Light Tree",description:"An introduction to the many lights sampling algorithm and how I plan to implement it in Blender.",section:"Posts",handler:()=>{window.location.href="/blog/2022/motivating-light-trees/"}},{id:"post-introduction-to-gsoc-with-blender",title:"Introduction to GSoC with Blender",description:"A self-introduction and my plans for this series.",section:"Posts",handler:()=>{window.location.href="/blog/2022/gsoc-introduction/"}},{id:"news-our-book-chapter-on-ray-tracing-large-voxel-scenes-has-been-published-as-part-of-gpu-zen-3-https-www-amazon-com-gpu-zen-advanced-rendering-techniques-dp-b0dnxnm14k-if-you-39-re-looking-for-some-reading-over-winter-break-please-check-it-out-a-big-thanks-to-all-of-the-editors-involved",title:"Our book chapter on ray tracing large voxel scenes has been published as...",description:"",section:"News"},{id:"news-happy-to-share-that-our-paper-on-offloaded-rendering-with-asynchronous-reprojection-has-been-accepted-to-mmsys-39-25-https-2025-acmmmsys-org-congratulations-to-everyone-involved",title:"Happy to share that our paper on offloaded rendering with asynchronous reprojection has...",description:"",section:"News"},{id:"news-i-39-m-very-grateful-to-receive-the-2025-nsf-graduate-research-fellowship-https-www-nsf-gov-funding-opportunities-grfp-nsf-graduate-research-fellowship-program-award",title:"I&#39;m very grateful to receive the 2025 [NSF Graduate Research Fellowship](https://www.nsf.gov/funding/opportunities/grfp-nsf-graduate-research-fellowship-program) Award.",description:"",section:"News"},{id:"news-excited-to-present-our-work-on-reservoir-splatting-at-siggraph-39-25-https-s2025-siggraph-org-huge-thanks-to-all-collaborators",title:"Excited to present our work on reservoir splatting at [SIGGRAPH&#39;25](https://s2025.siggraph.org/). Huge thanks to...",description:"",section:"News"},{id:"news-honored-to-receive-the-2025-c-w-gear-outstanding-undergraduate-student-https-siebelschool-illinois-edu-about-awards-undergraduate-scholarships-awards-cw-gear-outstanding-undergraduate-student-award",title:"Honored to receive the 2025 [C.W. Gear Outstanding Undergraduate Student](https://siebelschool.illinois.edu/about/awards/undergraduate-scholarships-awards/cw-gear-outstanding-undergraduate-student) Award.",description:"",section:"News"},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%6A%6C%69%75%31%37%39@%69%6C%6C%69%6E%6F%69%73.%65%64%75","_blank")}},{id:"socials-orcid",title:"ORCID",section:"Socials",handler:()=>{window.open("https://orcid.org/0009-0005-6976-808X","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=OWD4hSoAAAAJ","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/Jebbly","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/jeffrey-liu-604","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>