<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Supporting Point Lights | Jeffrey Liu </title> <meta name="author" content="Jeffrey Liu"> <meta name="description" content="A more detailed technical explanation of supporting the many lights algorithm for point lights in Blender."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/site_icon.jpg?81c0048f0ca63c3f56bd57b1992ac3e2"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jebbly.github.io/blog/2022/blender-point-lights/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/img-comparison-slider@8.0.6/dist/styles.min.css" integrity="sha256-3qTIuuUWIFnnU3LpQMjqiXc0p09rvd0dmj+WkpQXSR8=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@11.0.5/swiper-bundle.min.css" integrity="sha256-yUoNxsvX+Vo8Trj3lZ/Y5ZBf8HlBFsB6Xwm7rH75/9E=" crossorigin="anonymous"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Jeffrey</span> Liu </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog posts </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">personal projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">curriculum vitae </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">search <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Supporting Point Lights</h1> <p class="post-meta"> Created in June 18, 2022 </p> <p class="post-tags"> <a href="/blog/2022"> <i class="fa-solid fa-calendar fa-sm"></i> 2022 </a>   ·   <a href="/blog/tag/path-tracing"> <i class="fa-solid fa-hashtag fa-sm"></i> path-tracing</a>   ·   <a href="/blog/category/gsoc-2022"> <i class="fa-solid fa-tag fa-sm"></i> gsoc-2022</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>This is finally going to be a more technical post. As the title suggests, I’m going to cover how the many lights algorithm supports point lights in Blender. I expect this to be a slightly lengthier post because I want record some insights I’ve discovered about Cycles, some details that Brecht and Lukas have explained to me, and some more details about the algorithm itself. Before reading this, I would highly recommend reading either my previous posts or <a href="http://www.aconty.com/pdf/many-lights-hpg2018.pdf" rel="external nofollow noopener" target="_blank">the original paper</a>.</p> <p>Also, just as an update, it seems like Cycles has recently updated their device code and no longer refers to the device arrays as “textures” anymore. You’ll see what I mean if you read the section about transferring to device-side - just know that “data arrays” are now the equivalent of what I meant by “textures.”</p> <h2 id="implementation">Implementation</h2> <p>Before I get into the details of the implementation itself, I first want to go over some of what I’ve learned about Cycles. From what I understand, the device-side kernel has two main ways of keeping track of data. Both are stored in a struct called <code class="language-plaintext highlighter-rouge">KernelGlobals</code>. In this struct, it contains a member called <code class="language-plaintext highlighter-rouge">__data</code>, which in turn contains members such as the <code class="language-plaintext highlighter-rouge">integrator</code> that contains certain render settings and fixed constants. This takes up a fixed amount of memory and I imagine that it should be faster to access on the device. The struct also contains other data in the form of flat arrays. The amount of data that goes in here is dynamic, i.e. the lights in the scene. This is where we’ll also be adding new data such as the nodes of the light tree to traverse (more on that later).</p> <p>When Cycles starts rendering, the logic goes through a megakernel that determines which functions to call next. For example, the first function to call may be <code class="language-plaintext highlighter-rouge">integrator_intersect_closest()</code> to find an intersection. That function can write things to some state for other functions to read later, and it can also schedule the next kernel task. For example, after finding an intersection with a surface, we may want to queue <code class="language-plaintext highlighter-rouge">integrator_surface_direct_light()</code> which will sample a light, and then in turn call <code class="language-plaintext highlighter-rouge">integrator_intersect_shadow()</code> to check the visibilty of that light.</p> <p>Knowing this, there are essentially 3 main tasks:</p> <ol> <li>Using the scene information to construct the light tree on the host side,</li> <li>Transferring the light tree to access on the device side,</li> <li>Using the light tree to determine light sampling in the kernel.</li> </ol> <p>Next, I’ll elaborate on how each task was implemented.</p> <h3 id="host-side-construction">Host-side Construction</h3> <p>As I mentioned in an earlier post, the host-side construction of the light tree isn’t really anything notable. It follows PBRT very strictly, but we replace the surface area heuristic (SAH) with the surface area orientation heuristic. This is done by associating each light primitive and node with an additional bounding cone that keeps track of orientation and general emission direction. Here, we define a custom struct called <code class="language-plaintext highlighter-rouge">OrientationBounds</code> to keep track of this information:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern/cycles/scene/light_tree.h</span>
<span class="k">struct</span> <span class="nc">OrientationBounds</span> <span class="p">{</span>
  <span class="n">float3</span> <span class="n">axis</span><span class="p">;</span> <span class="cm">/* normal axis of the light */</span>
  <span class="kt">float</span> <span class="n">theta_o</span><span class="p">;</span> <span class="cm">/* angle bounding the normals */</span>
  <span class="kt">float</span> <span class="n">theta_e</span><span class="p">;</span> <span class="cm">/* angle bounding the light emissions */</span>
<span class="p">}</span>
</code></pre></div></div> <p>The reason we have both \(\theta_o\) and \(\theta_e\) is for certain light sources, like a point light. Since there’s really no “orientation axis” for a point light, we can technically consider any direction to be the orientation and then bound the axis to be within \(\theta_o = \pi\) radians of that direction. Then the \(\theta_e\) describes the angle of light that will be directed in the orientation axis. Again for a point light, this covers an angle of \(\pi/2\) around the orientation axis, and any angle past that will be facing behind the axis.</p> <p>When we merge two bounding cones, we find the centroid of the orientation axis, and then we compute new values for \(\theta_o\) and \(\theta_e\) that will bound that of the original two. This seems to be a generelly effective and safe approximation of the net bounding cone, but if I have time, I may consider somehow incorporating position data into this merge.</p> <h3 id="transferring-to-device-side">Transferring to Device-side</h3> <p>In my second post, I also discussed the sort of information that we need to access for traversal on the device side. I’ll explain why we need certain information in the next section, so this section is just focused on how we transform the information from the host-side into a flat array on the device side. We add have an array of this struct to be stored on the device:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern/cycles/kernel/types.h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">KernelLightTreeNode</span> <span class="p">{</span>
  <span class="cm">/* Bounding box. */</span>
  <span class="kt">float</span> <span class="n">bounding_box_min</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">float</span> <span class="n">bounding_box_max</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

  <span class="cm">/* Bounding cone. */</span>
  <span class="kt">float</span> <span class="n">bounding_cone_axis</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">float</span> <span class="n">theta_o</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">theta_e</span><span class="p">;</span>

  <span class="cm">/* Energy. */</span>
  <span class="kt">float</span> <span class="n">energy</span><span class="p">;</span>

  <span class="cm">/* If this is 0 or less, we're at a leaf node
  /* and the negative value indexes into the first child of the light array.
  /* Otherwise, it's an index to the node's second child. */</span>
  <span class="kt">int</span> <span class="n">child_index</span><span class="p">;</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">num_prims</span><span class="p">;</span> <span class="cm">/* leaf nodes need to know the number of primitives stored. */</span>
    <span class="kt">float</span> <span class="n">energy_variance</span><span class="p">;</span> <span class="cm">/* interior nodes use the energy variance for the splitting heuristic. */</span>
  <span class="p">};</span>

  <span class="cm">/* Padding. */</span>
  <span class="kt">int</span> <span class="n">pad1</span><span class="p">,</span> <span class="n">pad2</span><span class="p">;</span>
<span class="p">}</span> <span class="n">KernelLightTreeNode</span><span class="p">;</span>
<span class="n">static_assert_align</span><span class="p">(</span><span class="n">KernelLightTreeNode</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</code></pre></div></div> <p>In my previous post, I mentioned that we would use two separate structs to store interior and leaf nodes. However, as explained in the comments, we can use the <code class="language-plaintext highlighter-rouge">child_index</code> to determine whether or not a node is an interior or leaf node. Then the union is used to store the non-overlapping information. Other than that, we need the two extra <code class="language-plaintext highlighter-rouge">pad1, pad2</code> ints at the bottom to pad our struct so that it aligns to 16 bytes.</p> <p>Now we need to add an array of this struct to the <code class="language-plaintext highlighter-rouge">DeviceScene</code>. This is what we’ll actually be able to access through the kernels:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\scene\scene.h</span>
<span class="k">class</span> <span class="nc">DeviceScene</span> <span class="p">{</span>
<span class="nl">public:</span>
<span class="p">...</span>
<span class="cm">/* light tree */</span>
<span class="n">device_vector</span><span class="o">&lt;</span><span class="n">KernelLightTreeNode</span><span class="o">&gt;</span> <span class="n">light_tree_nodes</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">}</span>

<span class="c1">// intern\cycles\scene\scene.cpp</span>
<span class="n">DeviceScene</span><span class="o">::</span><span class="n">DeviceScene</span><span class="p">(</span><span class="n">Device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
    <span class="o">:</span> <span class="p">...,</span>
      <span class="n">light_tree_nodes</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="s">"__light_tree_nodes"</span><span class="p">,</span> <span class="n">MEM_GLOBAL</span><span class="p">),</span>
      <span class="p">...,</span>
<span class="p">{...}</span>
</code></pre></div></div> <p>The reason why we pass those parameters to initialize <code class="language-plaintext highlighter-rouge">light_tree_nodes</code> is because the <code class="language-plaintext highlighter-rouge">device_vector</code> uses this information when copying to the device. From my understanding, it’s kind of like an intermediary where we can fill in the <code class="language-plaintext highlighter-rouge">device_vector</code> from the host side, and then tell it to transfer that information to the device. In Cycles, arrays of data are stored as textures on the device, and the <code class="language-plaintext highlighter-rouge">device_vector</code> will look for a texture with the given name to populate. Ihis case, we passed in <code class="language-plaintext highlighter-rouge">"__light_tree_nodes"</code> as the name, so we need to make sure there’s an appropriate texture that corresponds to that name:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\textures.h</span>
<span class="p">...</span>
<span class="cm">/* light tree */</span>
<span class="n">KERNEL_TEX</span><span class="p">(</span><span class="n">KernelLightTreeNode</span><span class="p">,</span> <span class="n">__light_tree_nodes</span><span class="p">)</span>
<span class="p">...</span>
</code></pre></div></div> <p>The last thing we need to do is populate the <code class="language-plaintext highlighter-rouge">device_vector</code> before we tell it to transfer its data to the device. Since PBRT’s BVH construction already flattens the tree, all we need to do is iterate through the packed array and create the device-side struct accordingly. Sounds easy, but before we even construct the BVH, we first need to obtain an array with all the light primitives to be included in our BVH. Since we’re only dealing with point lights for now, this isn’t very interesting (and this post is getting quite lengthy), so I’ll omit it for a later discussion when more types are supported. For now, just trust that we’ve successfully transferred our linearized BVH onto the device through the texture <code class="language-plaintext highlighter-rouge">__light_tree_nodes</code>.</p> <h3 id="device-side-traversal">Device-side Traversal</h3> <p>Now that our light tree is on the device, we can use it to take more informed samples. When we begin at the very top parent of the light tree, we need some way to decide which child we should traverse to, i.e. what the relative importance of each child is. Recalling the rendering equation, there’s 2 main terms to consider:</p> <ol> <li>The irradiance term, \(L_i(p, \omega_i)\);</li> <li>The BSDF term, \(f(p, \omega_i, \omega_o)\).</li> </ol> <p>The importance of a node cluster should thus be an approximation of how much it relatively contributes to these terms. To do this, we want to loosely bound the range of possible values. This is the diagram that the original paper uses:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/gsoc/diagram-480.webp 480w,/assets/img/blog/gsoc/diagram-800.webp 800w,/assets/img/blog/gsoc/diagram-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/blog/gsoc/diagram.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>This is how the symbols are defined:</p> <ul> <li>\(\theta\) is the angle formed between the cluster’s bounding cone axis and the vector pointing from the centroid to the shading point,</li> <li>\(\theta_u\) is the max angle required to encompass the entire bounding box (around an vector pointing from the shading point to the centroid),</li> <li>\(\theta_i\) is the angle between the shading point normal and the centroid.</li> </ul> <p>The paper then gives the importance measure as follows:</p> \[I = \frac{f \lvert \cos(\theta_i') \rvert}{d^2} \times \begin{cases} \cos(\theta') &amp; \theta' &lt; \theta_e, \\ 0 &amp; \text{otherwise}. \end{cases}\] <p>where \(\theta_i' = max\{\theta_i - \theta_u, 0\}\) and \(\theta' = max\{\theta - \theta_o - \theta_u, 0\}\). These are a lot of new terms, but hopefully you can see some loose similarities between this importance measure formula and the integrand in the rendering equation. This is my interpretation of \(\theta_i'\) and \(\theta'\):</p> <ul> <li>\(\theta_i'\) is the minimum angle that could possibly be formed between the shading point normal and a vector pointing from the shading point to a light in the cluster,</li> <li>\(\theta'\) is the minimum angle between the emitter normal and a vector pointing from a light in the cluster to the shading point.</li> </ul> <p>These heuristics are all very loose bounds, but it’s still a decent approximation to determine the weight of sampling each cluster.</p> <p>Writing all the code here would be pretty redundant because as of right now, it’s a pretty immediate mapping from math to code. If you want to look through it, it can be found at <code class="language-plaintext highlighter-rouge">intern\cycles\kernel\light_tree.h</code>. Most of the angles are either already given, or can be calculated by taking \(\cos^{-1}\) of the dot product between the two normalized vectors in question. The only somewhat notable calculation is \(\theta_u\) because there’s no easy way to know what minimum angle will encompass the entire bounding box. As such, we must iterate through each point of the bounding box to find the max angle formed (which will contain all the others).</p> <p>Once we have the relative importance of each child, we assign the probability of traversing to the first and second child (this is also referred to as left and right in the code):</p> \[\mathbb{P}_1 = \frac{I_1}{I_1 + I_2}, \quad \mathbb{P}_2 = \frac{I_2}{I_1 + I_2}.\] <p>Thus, in order to reach a given light, we have to traverse through its ancestors with a given probability each time. At each step in the traversal, we need to make sure the PDF of selecting our light is correct, so we use a <code class="language-plaintext highlighter-rouge">pdf_factor</code> to scale our PDF based on which direction we chose. For example, if we traversed in the order \(L_1, R_2, L_3\), then we also scale our <code class="language-plaintext highlighter-rouge">pdf_factor</code> by \(P_{L_1} \cdot P_{R_2} \cdot P_{L_3}\).</p> <p>Finally, the last step is less related to the paper and more so to Blender’s code. Right now, Blender samples lights and emissive triangles by generating a distribution where each primitive’s <code class="language-plaintext highlighter-rouge">totarea</code> represents its relative weight of being selected. The distribution is “pre-baked” in the sense that it creates a 50-50 probability of selecting either a triangle or a light. Then the probability of selecting a triangle (given that a triangle was selected) is now proportional to its area, and there’s an even probability of selecting any light. Therefore, we have the following code:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\scene\light.cpp</span>
<span class="k">if</span> <span class="p">(</span><span class="n">trianglearea</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">kintegrator</span><span class="o">-&gt;</span><span class="n">pdf_triangles</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="n">trianglearea</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">num_lights</span><span class="p">)</span>
    <span class="n">kintegrator</span><span class="o">-&gt;</span><span class="n">pdf_triangles</span> <span class="o">*=</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">num_lights</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">kintegrator</span><span class="o">-&gt;</span><span class="n">pdf_lights</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="n">num_lights</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">trianglearea</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">)</span>
    <span class="n">kintegrator</span><span class="o">-&gt;</span><span class="n">pdf_lights</span> <span class="o">*=</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Then the function <code class="language-plaintext highlighter-rouge">light_sample()</code> in the device kernel uses this PDF factor to scale the light sample’s PDF after the rest of the computation. In our case, we still want to use the <code class="language-plaintext highlighter-rouge">light_sample()</code> function, but this baked distribution is no longer being used in our sampling logic. The PDF is dynamic depending on the importance and we’re scaling it in our own sampling function, so we can’t use any pre-baked data. Instead, we just override the factors so that <code class="language-plaintext highlighter-rouge">light_sample()</code> doesn’t additionally scale our PDF incorrectly:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\scene\light.cpp</span>
<span class="k">if</span> <span class="p">(</span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">integrator</span><span class="o">-&gt;</span><span class="n">get_use_light_tree</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">kintegrator</span><span class="o">-&gt;</span><span class="n">pdf_triangles</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">;</span>
  <span class="n">kintegrator</span><span class="o">-&gt;</span><span class="n">pdf_lights</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="c1">// code from above</span>
<span class="p">}</span>
</code></pre></div></div> <p>If you’ve read the original paper, “Importance Sampling of Many Lights With Adaptive Tree Splitting” by Alejandro Conty Estevez and Christopher Kulla, or my previous post, you may also recall that there’s also something called the splitting threshold. This is when variance of the child nodes is too high, so we choose to sample from both the left and right child instead. However, this implementation isn’t very convenient in the context of how Cycles functions. Since we have to queue kernel tasks and <code class="language-plaintext highlighter-rouge">integrate_surface_direct_light()</code> expects to handle a single light at a time, we’d have to do some weird workarounds to implement the splitting threshold (which samples multiple lights at a time). For now, we’re putting this to the side, but we’ll re-examine it later when the implementation is more stable.</p> <h3 id="debugging-testing-and-benchmarking">Debugging, Testing, and Benchmarking</h3> <p>To debug and test this scene, I created a bunch of scenes that just had a bunch of point lights and no background light. To start, the goal was to get a single point light and cube rendering properly. LazyDodo pointed me towards a useful tool called <code class="language-plaintext highlighter-rouge">idiff</code> which can be used to compare 2 renders, which I would use to verify the accuracy of my implementation when compared to the default Cycles render. It also lets you output a difference image and scale the results (to make it easier to see), which was very useful. Lukas also recommended another tool, <a href="https://github.com/Tom94/tev" rel="external nofollow noopener" target="_blank">tev</a>, to compare images, but I haven’t gotten the chance to try it out yet. Anyways, this is an example of why <code class="language-plaintext highlighter-rouge">idiff</code> is important; here are two of the first renders I did. With one point light, no background light, and a single cube, the left is the Cycles default implementation and the right is my new implementation:</p> <img-comparison-slider> <figure slot="first"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/gsoc/correct-render-480.webp 480w,/assets/img/blog/gsoc/correct-render-800.webp 800w,/assets/img/blog/gsoc/correct-render-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/blog/gsoc/correct-render.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure slot="second"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/gsoc/test-render-480.webp 480w,/assets/img/blog/gsoc/test-render-800.webp 800w,/assets/img/blog/gsoc/test-render-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/blog/gsoc/test-render.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </img-comparison-slider> <p>Looks pretty similar, right? Maybe to the naked eye, but <code class="language-plaintext highlighter-rouge">idiff</code> shows the following when I scale the absolute difference by 100:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/gsoc/diff-480.webp 480w,/assets/img/blog/gsoc/diff-800.webp 800w,/assets/img/blog/gsoc/diff-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/blog/gsoc/diff.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>In reality, the right corner of my implementation is too dark while the other corners are too bright. There were actually a few things wrong with my first implementation. I accidentally swapped the normal and position arguments (this took an embarrasingly long time to figure out), and I didn’t account for the pre-baked light PDFs.</p> <p>Other errors included:</p> <ul> <li>Forgetting to update the node’s energy when transferring it to the device</li> <li>Not initializing the bounding box and bounding cones properly when doing SAOH</li> <li>Forgetting to scale the random number used</li> <li>Swapping the values for \(\theta_i'\) and \(\theta'\) Last but certainly not least, this was the error that took me at least 7 hours to debug:</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light_tree.h</span>
<span class="k">if</span> <span class="p">(</span><span class="n">tree_u</span> <span class="o">&lt;</span> <span class="n">left_probability</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">knode</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
  <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">tree_u</span> <span class="o">=</span> <span class="n">tree_u</span> <span class="o">*</span> <span class="p">(</span><span class="n">left_importance</span> <span class="o">+</span> <span class="n">right_importance</span><span class="p">)</span> <span class="o">/</span> <span class="n">left_importance</span><span class="p">;</span>
  <span class="o">*</span><span class="n">pdf_factor</span> <span class="o">*=</span> <span class="n">left_probability</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="n">knode</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
  <span class="n">index</span> <span class="o">=</span> <span class="n">knode</span><span class="o">-&gt;</span><span class="n">child_index</span><span class="p">;</span>
  <span class="n">tree_u</span> <span class="o">=</span> <span class="p">(</span><span class="n">tree_u</span> <span class="o">*</span> <span class="p">(</span><span class="n">left_importance</span> <span class="o">+</span> <span class="n">right_importance</span><span class="p">)</span> <span class="o">-</span> <span class="n">left_importance</span><span class="p">)</span> <span class="o">/</span>
            <span class="n">right_importance</span><span class="p">;</span>
  <span class="o">*</span><span class="n">pdf_factor</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">left_probability</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>The error is in the else statement, where <code class="language-plaintext highlighter-rouge">knode = right</code> is called before <code class="language-plaintext highlighter-rouge">index = knode-&gt;child_index</code>. As a result, when we traverse to the node where <code class="language-plaintext highlighter-rouge">child_index</code> is set to the last index in the array, we’re now in an interior node but <code class="language-plaintext highlighter-rouge">index</code> is the last index possible. Then since <code class="language-plaintext highlighter-rouge">knode</code> is still at an interior node, we try to access the left child which is <code class="language-plaintext highlighter-rouge">index + 1</code> and thus out of bounds.</p> <p>I guess after a few hours of debugging already, I didn’t have it in me to catch this bug by inspection - I honestly wasn’t expecting this error at all. Since the conditional is probabilistic, I never encountered it when I was stepping through the code line-by-line. I was also running the render tests through a release-mode build where there were no assertions. I finally hit the assertion fail when I accidentally continued execution in my line-by-line debugging in a debug-mode build.</p> <p>Now the implementation finally has some degree of accuracy when it comes to point lights (at least in special cases). In scenes with lots of point lights, there seems to be some more significant differences in the edges of the cubes. When I increase the sample size, the error there does still decrease, but at a slower rate than the rest of the render. This might be something I’ll look into again later, but I suspect that it’s mostly a precision thing, or something related to the normals near the edges of the cube.</p> <p>Overall, debugging took me way longer than I’d like to admit, but in a sense, I guess it’s a necessary evil. I definitely learned a lot through it, and I hope that addressing these errors early on will make it easier when debugging further features.</p> <h2 id="closing-thoughts">Closing Thoughts</h2> <p>This was my first time really diving into Blender’s source code, so it was really rewarding when some of the tests started passing. That said, it’s still a little too early to start celebrating because these are just special test cases. There’s a lot more testing that needs to be done, and then after that, it’ll be time for optimizations too. As I mentioned in the devtalk, the rough timeline is as follows:</p> <ol> <li>Spot and area lights</li> <li>Emissive triangles</li> <li>Background and distant lights</li> <li>Volumes</li> <li>GPU Implementation</li> </ol> <p>As for the immediate next steps it should be pretty easy to support spot lights and area lights. Since they’re just different lights, it should just be a matter of handling their orientation bounds appropriately. After that, emissive triangles are next on the list - this should also be relatively straight-forward to implement as long as the bounds are constructed properly.</p> <p>As usual, please let me know if there are any errors in this post - I would love to better my understanding of things! If you have any questions or concerns, feel free to ask on <a href="https://devtalk.blender.org/t/gsoc-2022-many-lights-sampling-in-cycles-x-feedback-thread/24773" rel="external nofollow noopener" target="_blank">the devtalk feedback thread</a>. If you also have any scenes with a lot of lights, please do share them! I’ll try to test them as soon as it’s ready for testing.</p> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Jeffrey Liu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: January 28, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-GB73T9E4G9"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-GB73T9E4G9");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script defer src="https://cdn.jsdelivr.net/npm/img-comparison-slider@8.0.6/dist/index.min.js" integrity="sha256-EXHg3x1K4oIWdyohPeKX2ZS++Wxt/FRPH7Nl01nat1o=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/swiper@11.0.5/swiper-element-bundle.min.js" integrity="sha256-BPrwikijIybg9OQC5SYFFqhBjERYOn97tCureFgYH1E=" crossorigin="anonymous"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-publications",title:"publications",description:"(* denotes equal contribution)",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"nav-blog-posts",title:"blog posts",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-personal-projects",title:"personal projects",description:"Most of my work in the past few years has been related to work or research, so I haven&#39;t found too much time for personal projects recently. The projects listed here are mostly old or coursework related, so I&#39;m not sharinig them because I think they&#39;re impressive, but because I think they still represent things I&#39;m interested in. Hoping to find time to add to this in the near future!",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-curriculum-vitae",title:"curriculum vitae",description:"This page just has some basic information. For a (slightly more) complete research and work CV, please download the attached PDF.",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"post-reflecting-on-gsoc-2022",title:"Reflecting on GSoC 2022",description:"A three month late reflection on GSoC 2022.",section:"Posts",handler:()=>{window.location.href="/blog/2022/gsoc-conclusion/"}},{id:"post-weighted-reservoir-sampling-for-adaptive-splitting",title:"Weighted Reservoir Sampling for Adaptive Splitting",description:"The Cycles version of adaptive splitting.",section:"Posts",handler:()=>{window.location.href="/blog/2022/adaptive-splitting/"}},{id:"post-correcting-for-multiple-importance-sampling",title:"Correcting for Multiple Importance Sampling",description:"Fixes to the PDF calculations to adjust for the light tree sampling.",section:"Posts",handler:()=>{window.location.href="/blog/2022/light-tree-mis/"}},{id:"post-adding-more-light-types",title:"Adding More Light Types",description:"How different light types in Blender are used in the many lights sampling algorithm.",section:"Posts",handler:()=>{window.location.href="/blog/2022/more-light-types/"}},{id:"post-supporting-point-lights",title:"Supporting Point Lights",description:"A more detailed technical explanation of supporting the many lights algorithm for point lights in Blender.",section:"Posts",handler:()=>{window.location.href="/blog/2022/blender-point-lights/"}},{id:"post-motivating-many-lights-sampling-with-a-light-tree",title:"Motivating Many Lights Sampling with a Light Tree",description:"An introduction to the many lights sampling algorithm and how I plan to implement it in Blender.",section:"Posts",handler:()=>{window.location.href="/blog/2022/motivating-light-trees/"}},{id:"post-introduction-to-gsoc-with-blender",title:"Introduction to GSoC with Blender",description:"A self-introduction and my plans for this series.",section:"Posts",handler:()=>{window.location.href="/blog/2022/gsoc-introduction/"}},{id:"news-our-book-chapter-on-ray-tracing-large-voxel-scenes-has-been-published-as-part-of-gpu-zen-3-https-www-amazon-com-gpu-zen-advanced-rendering-techniques-dp-b0dnxnm14k-if-you-39-re-looking-for-some-reading-over-winter-break-please-check-it-out-a-big-thanks-to-all-of-the-editors-involved",title:"Our book chapter on ray tracing large voxel scenes has been published as...",description:"",section:"News"},{id:"news-happy-to-share-that-paper-on-offloaded-rendering-with-asynchronous-reprojection-has-been-accepted-to-mmsys-39-25-https-2025-acmmmsys-org-congratulations-to-everyone-involved",title:"Happy to share that paper on offloaded rendering with asynchronous reprojection has been...",description:"",section:"News"},{id:"projects-ascii-rasterizer",title:"ASCII Rasterizer",description:"Interactive (CPU) software rasterizer with CLI display.",section:"Projects",handler:()=>{window.location.href="/projects/ascii-rasterizer/"}},{id:"projects-hand-tracker",title:"Hand Tracker",description:"Stereo hand tracker with multi-CNN prediction and triplane fusion.",section:"Projects",handler:()=>{window.location.href="/projects/hand-tracking/"}},{id:"projects-holography",title:"Holography",description:"Lab on holographic recording and reconstruction.",section:"Projects",handler:()=>{window.location.href="/projects/holography/"}},{id:"projects-raycast-engine",title:"Raycast Engine",description:"Implementation of raycasting and floorcasting in Python.",section:"Projects",handler:()=>{window.location.href="/projects/python-raycaster/"}},{id:"projects-style-share",title:"Style Share",description:"Web-based 3D engine with neural stylization post processing.",section:"Projects",handler:()=>{window.location.href="/projects/style-share/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%6A%6C%69%75%31%37%39@%69%6C%6C%69%6E%6F%69%73.%65%64%75","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/Jebbly","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/jeffrey-liu-604","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>