<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Correcting for Multiple Importance Sampling | Jeffrey Liu </title> <meta name="author" content="Jeffrey Liu"> <meta name="description" content="Fixes to the PDF calculations to adjust for the light tree sampling."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/site_icon.jpg?81c0048f0ca63c3f56bd57b1992ac3e2"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jebbly.github.io/blog/2022/light-tree-mis/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Jeffrey</span> Liu </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog posts </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">personal projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">curriculum vitae </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">search <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Correcting for Multiple Importance Sampling</h1> <p class="post-meta"> Created in July 09, 2022 </p> <p class="post-tags"> <a href="/blog/2022"> <i class="fa-solid fa-calendar fa-sm"></i> 2022 </a>   ·   <a href="/blog/tag/path-tracing"> <i class="fa-solid fa-hashtag fa-sm"></i> path-tracing</a>   ·   <a href="/blog/category/gsoc-2022"> <i class="fa-solid fa-tag fa-sm"></i> gsoc-2022</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>If you recall from my second post, importance sampling is the name of the game, but I actually kind of omitted something from that chapter. Notice that there’s actually two main terms in the integrand of the rendering equation:</p> \[L_o(p, \omega_o) = L_e(p, \omega_o) + \int_\Omega f(x, \omega_i, \omega_o) L_i(p, \omega_i) \,d \omega_i\] <p>So it’s great if we’re looking for light sources that are really strong and contribute a lot to the \(L_i\) term, but there’s a slight issue. For example, consider a scenario where we’re looking across a mirror from a very shallow angle and there’s a really strong light source that’s directly above the mirror. Turns out, that light source isn’t really contributing much to what we’re seeing at all! The issue is that the BSDF term also plays a role in our integrand, and we’re going to have a lot of trouble if we keep focusing our samples towards a strong light source and isn’t contributing all that much. Thankfully, people have come up with a pretty good solution: multiple importance sampling!</p> <h2 id="multiple-importance-sampling">Multiple Importance Sampling</h2> <p>The idea of multiple importance sampling is to take some samples based on both terms of the integrand (in this case, \(f\) and \(L_i\)). As PBRT mentions, we can’t just define two separate estimators that each use a different sampling distribution because the variance is additive. Instead, we use the estimator given by:</p> \[\frac{1}{n_f} \sum_{i = 1}^{n_f} \frac{f(X_i) g(X_i) w_f(X_i)}{p_f(X_i)} + \frac{1}{n_g} \sum_{i = 1}^{n_g} \frac{f(X_i) g(X_i) w_g(X_i)}{p_g(X_i)}\] <p>Here, \(n_f, n_g\) are the number of samples used from the \(p_f, p_g\) distributions respectively. The \(w_f\) and \(w_g\) terms correspond to a weighting heuristic (that should sum to 1). It’s relative straightforward to verify this estimator is still unbiased:</p> \[\begin{aligned} \mathbb{E}[F] &amp;= \mathbb{E}\left[\frac{1}{n_f} \sum_{i = 1}^{n_f} \frac{f(X_i) g(X_i) w_f(X_i)}{p_f(X_i)} + \frac{1}{n_g} \sum_{i = 1}^{n_g} \frac{f(X_i) g(X_i) w_g(X_i)}{p_g(X_i)} \right] \\ &amp;= \frac{1}{n_f} (n_f) \mathbb{E}\left[ \frac{f(X_i) g(X_i) w_f(X_i)}{p_f(X_i)} \right] + \frac{1}{n_g} (n_g) \mathbb{E}\left[ \frac{f(X_i) g(X_i) w_g(X_i)}{p_g(X_i)} \right] \\ &amp;= \int \frac{f(x) g(x) w_f(x)}{p_f(x)} p_f((x) \,dx + \int \frac{f(x) g(x) w_g(x)}{p_g(x)} p_g(x) \,dx \\ &amp;= \int f(x) g(x) w_f(x) \,dx + \int f(x) g(x) w_g(x) \,dx \\ &amp;= \int f(x) g(x) (w_f(x) + w_g(x)) \,dx \\ &amp; = \int f(x) g(x) \,dx. \end{aligned}\] <p>In Cycles, each pass of <code class="language-plaintext highlighter-rouge">integrator_shade_surface()</code> actually takes two samples: one for direct lighting (only sampling light sources) and one for indirect lighting (sampling based on the BSDF). The weighting used is the power heuristic, which simplifies slightly because \(n_f = n_g = n\) in this case:</p> \[w_f(x_i) = \frac{(n_f p_f(x_i))^2}{(n_f p_f(x_i))^2 + (n_g p_g(x_i))^2} = \frac{n^2 p_f(x_i)^2}{n^2(p_f(x_i)^2 + p_g(x_i)^2)} = \frac{p_f(x_i)^2}{p_f(x_i)^2 + p_g(x_i)^2}.\] <p>The same calculation can be done for \(w_g(x_i)\). The important thing to note here is that, in order to calculate the proper power heuristic for a given sample, we actually need to compute the direct light PDF as well as the indirect light PDF. We’re not going to worry too much about the indirect light PDF because we’re not changing anything there, so the rest of this post is focused on how the direct light PDF needs to be adjusted.</p> <h2 id="many-lights-sampling-pdfs">Many Lights Sampling PDFs</h2> <p>In the default implementation where direct lighting is sampled based on the light distribution (as I’ve mentioned many times before), it’s pretty simple to compute the PDF. In fact, most of it is already pre-computed during construction:</p> <ul> <li>Light sources have a <code class="language-plaintext highlighter-rouge">1 / num_lights</code> probability of being chosen</li> <li>Triangles have an <code class="language-plaintext highlighter-rouge">area / total_area</code> (where <code class="language-plaintext highlighter-rouge">total_area</code> is the total area of all the triangles) probability of being chosen</li> <li>If there are both light sources and triangles involved, divide those probabilities in half (because either a light or a triangle is chosen)</li> </ul> <p>When we sample from the BSDF and we happen to intersect with a light source, we basically already have all this information. The only additional computation to be made is if we need to calculate a specific triangle’s area.</p> <p>Things get a little complicated, to say the least, when it comes to sampling from the light tree. The main issue is that the direct light sampling distribution is position-dependent. As a result, there isn’t much information to compute during construction, and we need to calculate the probability of sampling that light source from whatever point we were sampling from. To review how we sample light sources:</p> <ul> <li>First, we sample either from the light tree or the distant light group (probability based on relative energies)</li> <li>If we choose the light tree, we traverse down the binary tree (according to their relative importances) until we hit a leaf node <ul> <li>At a leaf node, we sample based off of a CDF constructed from the relative importances of the light sources in the leaf</li> </ul> </li> <li>If we choose the distant light group, we immediately sample based off of a CDF constructed from the relative importances</li> </ul> <h3 id="a-brief-interlude">A Brief Interlude</h3> <p>Before we even get to all those PDF calculations, the more pressing question is how to actually find the light source from the distant group or the light tree. It’s easy to start from the top and pick a light source in the light tree, but what about the converse? Given some light source, how do we know where it would be in the light tree? The same issue holds for the distant lights group.</p> <p>My first idea was to attach another member variable to the <code class="language-plaintext highlighter-rouge">KernelLight</code> struct, which would point back to the corresponding index in the light tree emitters array or the distant lights array. Something similar would need to be done for triangles. The issue with this approach is that the <code class="language-plaintext highlighter-rouge">KernelLight</code> struct is already perfectly aligned to 16 bytes, so adding another member variable (4 bytes for an int) would also require an additional 12 bytes of padding for alignment. Furthermore, not every triangle is an emitter, so it would be holding empty information. Lastly, this member is also useless if the light tree isn’t being used.</p> <p>My next idea was to instead creating separate arrays which would store their corresponding indices in the light tree setup. For example, if we’re at a triangle with index 0, then we query the triangle array at index 0 for its index in <code class="language-plaintext highlighter-rouge">light_tree_emitters</code>. We do this for both light sources and triangles, but the corresponding indices for distant lights will index into the distant lights array:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">KERNEL_DATA_ARRAY</span><span class="p">(</span><span class="n">uint</span><span class="p">,</span> <span class="n">light_to_tree</span><span class="p">)</span>
<span class="n">KERNEL_DATA_ARRAY</span><span class="p">(</span><span class="n">uint</span><span class="p">,</span> <span class="n">triangle_to_tree</span><span class="p">)</span>
</code></pre></div></div> <p>You may have noticed that this array needs to match the size of all the triangles, emissive or not, in order to work. The tradeoff here is that we’re using up a bit of unnecessary memory, but the lookup times are fast and constant. Now that we know where we are in the light tree, we can start worrying about how to calculate the probability of reaching that location.</p> <h3 id="light-tree-group">Light Tree Group</h3> <p>The harder case is the light tree because the direct light sampling method relies on traversing down a binary tree before arriving at some light source; in the case of sampling a light from the indirect light sampling, we’re given a specific light source and asked to calculate the probability of sampling it. To do this, we’ll need a way to go back up the tree in order to compare importances at each level. The easiest way to do that is to update our <code class="language-plaintext highlighter-rouge">LightTreeNode</code> and <code class="language-plaintext highlighter-rouge">LightTreeEmitter</code> structs to store its parent index. It works out perfectly because our structs already had some extra padding anyways:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\types.h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">KernelLightTreeNode</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="cm">/* Parent. */</span>
  <span class="kt">int</span> <span class="n">parent_index</span><span class="p">;</span>

  <span class="cm">/* Padding. */</span>
  <span class="kt">int</span> <span class="n">pad1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">KernelLightTreeNode</span><span class="p">;</span>
<span class="n">static_assert_align</span><span class="p">(</span><span class="n">KernelLightTreeNode</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">KernelLightTreeEmitter</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="cm">/* Parent. */</span>
  <span class="kt">int</span> <span class="n">parent_index</span><span class="p">;</span>
<span class="p">}</span> <span class="n">KernelLightTreeEmitter</span><span class="p">;</span>
<span class="n">static_assert_align</span><span class="p">(</span><span class="n">KernelLightTreeEmitter</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</code></pre></div></div> <p>This means we also need to update our light tree construction too. When we’re finishing up construction during <code class="language-plaintext highlighter-rouge">LightTree::flatten_tree</code>, we attach an extra argument to indicate the index of the parent:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\scene\light_tree.cpp</span>
<span class="kt">int</span> <span class="n">LightTree</span><span class="o">::</span><span class="n">flatten_tree</span><span class="p">(</span><span class="k">const</span> <span class="n">LightTreeBuildNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">int</span> <span class="n">current_index</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
  <span class="n">offset</span><span class="o">++</span><span class="p">;</span>

  <span class="cm">/* If current node contains lights, then it is a leaf node.
   * Otherwise, create interior node and children recursively. */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_lights</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">first_prim_index</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">first_prim_index</span><span class="p">;</span>
    <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">num_lights</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">num_lights</span><span class="p">;</span>
    <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">is_leaf_node</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">num_lights</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">is_leaf_node</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="cm">/* The first child is located directly to the right of the parent. */</span>
    <span class="n">flatten_tree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">offset</span><span class="p">,</span> <span class="n">current_index</span><span class="p">);</span>
    <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">second_child_index</span> <span class="o">=</span> <span class="n">flatten_tree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">offset</span><span class="p">,</span> <span class="n">current_index</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">current_index</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Note that the first call to this function passes an argument of <code class="language-plaintext highlighter-rouge">-1</code> to the <code class="language-plaintext highlighter-rouge">parent</code> parameter, so we know when we’re at the root. Now that we have a way to traverse up the tree, we’re ready to try calculating some probabilities! The first step is to find the probability of actually sampling from the light tree, which is its relative importance compared to the distant lights:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light_tree.h</span>
<span class="n">ccl_device</span> <span class="kt">float</span> <span class="nf">light_tree_pdf</span><span class="p">(</span><span class="n">KernelGlobals</span> <span class="n">kg</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">P</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">N</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">prim</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">float</span> <span class="n">distant_light_importance</span> <span class="o">=</span> <span class="n">light_tree_distant_light_importance</span><span class="p">(</span>
      <span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distant_lights</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">light_tree_importance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distribution</span> <span class="o">&gt;</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distant_lights</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">ccl_global</span> <span class="n">KernelLightTreeNode</span> <span class="o">*</span><span class="n">kroot</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_tree_nodes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">light_tree_importance</span> <span class="o">=</span> <span class="n">light_tree_cluster_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">kroot</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="kt">float</span> <span class="n">total_group_importance</span> <span class="o">=</span> <span class="n">light_tree_importance</span> <span class="o">+</span> <span class="n">distant_light_importance</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">total_group_importance</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">pdf</span> <span class="o">=</span> <span class="n">light_tree_importance</span> <span class="o">/</span> <span class="n">total_group_importance</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>Next, we find the probability of actually selecting the light when we’re at the leaf node:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light_tree.h</span>
<span class="n">ccl_device</span> <span class="kt">float</span> <span class="nf">light_tree_pdf</span><span class="p">(</span><span class="n">KernelGlobals</span> <span class="n">kg</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">P</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">N</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">prim</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">emitter</span> <span class="o">=</span> <span class="p">(</span><span class="n">prim</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">triangle_to_tree</span><span class="p">,</span> <span class="n">prim</span><span class="p">)</span> <span class="o">:</span> <span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_to_tree</span><span class="p">,</span> <span class="o">~</span><span class="n">prim</span><span class="p">);</span>
  <span class="n">ccl_global</span> <span class="k">const</span> <span class="n">KernelLightTreeEmitter</span><span class="o">*</span> <span class="n">kemitter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_tree_emitters</span><span class="p">,</span>
                                                                         <span class="n">emitter</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">kemitter</span><span class="o">-&gt;</span><span class="n">parent_index</span><span class="p">;</span>
  <span class="n">ccl_global</span> <span class="k">const</span> <span class="n">KernelLightTreeNode</span><span class="o">*</span> <span class="n">kleaf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_tree_nodes</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>

  <span class="cm">/* First, we find the probability of selecting the primitive out of the leaf node. */</span>
  <span class="kt">float</span> <span class="n">total_importance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">emitter_importance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kleaf</span><span class="o">-&gt;</span><span class="n">num_prims</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">prim</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">kleaf</span><span class="o">-&gt;</span><span class="n">child_index</span><span class="p">;</span> <span class="cm">/* At a leaf node, the negative value is the index into first prim. */</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">importance</span> <span class="o">=</span> <span class="n">light_tree_emitter_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">prim</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">emitter</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">emitter_importance</span> <span class="o">=</span> <span class="n">importance</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">total_importance</span> <span class="o">+=</span> <span class="n">importance</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">pdf</span> <span class="o">*=</span> <span class="n">emitter_importance</span> <span class="o">/</span> <span class="n">total_importance</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>We use our newly created arrays to find out the position in the <code class="language-plaintext highlighter-rouge">light_tree_emitters</code>, and we then query the <code class="language-plaintext highlighter-rouge">parent_index</code> to find which leaf node contains this emitter. Our leaf node contains all the information we need about the primitives it contains, so we iterate through and find our specific primitive’s relative weight. Next, we want to find the probability of actually traversing to this leaf node:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light_tree.h</span>
<span class="n">ccl_device</span> <span class="kt">float</span> <span class="nf">light_tree_pdf</span><span class="p">(</span><span class="n">KernelGlobals</span> <span class="n">kg</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">P</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">N</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">prim</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="cm">/* Next, we find the probability of traversing to that leaf node. */</span>
  <span class="kt">int</span> <span class="n">child_index</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
  <span class="n">parent</span> <span class="o">=</span> <span class="n">kleaf</span><span class="o">-&gt;</span><span class="n">parent_index</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">ccl_global</span> <span class="n">KernelLightTreeNode</span> <span class="o">*</span><span class="n">kparent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_tree_nodes</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">left_index</span> <span class="o">=</span> <span class="n">parent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">right_index</span> <span class="o">=</span> <span class="n">kparent</span><span class="o">-&gt;</span><span class="n">child_index</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">ccl_global</span> <span class="n">KernelLightTreeNode</span> <span class="o">*</span><span class="n">kleft</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_tree_nodes</span><span class="p">,</span> <span class="n">left_index</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">ccl_global</span> <span class="n">KernelLightTreeNode</span> <span class="o">*</span><span class="n">kright</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_tree_nodes</span><span class="p">,</span> <span class="n">right_index</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">float</span> <span class="n">left_importance</span> <span class="o">=</span> <span class="n">light_tree_cluster_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">kleft</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">right_importance</span> <span class="o">=</span> <span class="n">light_tree_cluster_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">kright</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">left_probability</span> <span class="o">=</span> <span class="n">left_importance</span> <span class="o">/</span> <span class="p">(</span><span class="n">left_importance</span> <span class="o">+</span> <span class="n">right_importance</span><span class="p">);</span>

    <span class="cm">/* If the child index matches the left index, then we must've traversed left, otherwise right. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left_index</span> <span class="o">==</span> <span class="n">child_index</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pdf</span> <span class="o">*=</span> <span class="n">left_probability</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">pdf</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">left_probability</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">child_index</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">kparent</span><span class="o">-&gt;</span><span class="n">parent_index</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">pdf</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>At any node, we go up to the parent node so that we can compare the children. We also keep track of the child node’s index, so we can actually tell whether it was the left or right node. We continue this until our parent index reaches <code class="language-plaintext highlighter-rouge">-1</code>, which indicates that we’ve already hit the root. At this point, we’ve accounted for everything:</p> <ul> <li>The probability of sampling the light tree over the distant lights;</li> <li>The probability of sampling the specific leaf node containing our primitive;</li> <li>The probability of sampling our primitive out of all the primitives in the leaf.</li> </ul> <p>This is the entire process of sampling the light tree, so we can finally return our computed PDF!</p> <h3 id="distant-light-group">Distant Light Group</h3> <p>The easy case to compute the PDF is the distant lights group. All we have to do is calculate the importance of that specific light, and then divide that by the total importance of the distant lights. We also need to multiply by the probability of sampling from the distant light group and not the light tree:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light_tree.h</span>
<span class="n">ccl_device</span> <span class="kt">float</span> <span class="nf">distant_lights_pdf</span><span class="p">(</span><span class="n">KernelGlobals</span> <span class="n">kg</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">P</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">N</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">prim</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">float</span> <span class="n">distant_light_importance</span> <span class="o">=</span> <span class="n">light_tree_distant_light_importance</span><span class="p">(</span>
      <span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distant_lights</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">light_tree_importance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distribution</span> <span class="o">&gt;</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distant_lights</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">ccl_global</span> <span class="n">KernelLightTreeNode</span> <span class="o">*</span><span class="n">kroot</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_tree_nodes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">light_tree_importance</span> <span class="o">=</span> <span class="n">light_tree_cluster_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">kroot</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="kt">float</span> <span class="n">total_group_importance</span> <span class="o">=</span> <span class="n">light_tree_importance</span> <span class="o">+</span> <span class="n">distant_light_importance</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">total_group_importance</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">pdf</span> <span class="o">=</span> <span class="n">distant_light_importance</span> <span class="o">/</span> <span class="n">total_group_importance</span><span class="p">;</span>

  <span class="cm">/* The light_to_tree array doubles as a lookup table for
   * both the light tree as well as the distant lights group.*/</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">distant_light</span> <span class="o">=</span> <span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_to_tree</span><span class="p">,</span> <span class="n">prim</span><span class="p">);</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">num_distant_lights</span> <span class="o">=</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distant_lights</span><span class="p">;</span>

  <span class="kt">float</span> <span class="n">emitter_importance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">total_importance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_distant_lights</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">importance</span> <span class="o">=</span> <span class="n">light_tree_distant_light_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">distant_light</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">emitter_importance</span> <span class="o">=</span> <span class="n">importance</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">total_importance</span> <span class="o">+=</span> <span class="n">importance</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">pdf</span> <span class="o">*=</span> <span class="n">emitter_importance</span> <span class="o">/</span> <span class="n">total_importance</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">pdf</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>The calculation here is pretty straight-forward. Similar to the calculation in the light tree, we cache the emitter’s importance while we’re computing the total importance.</p> <h2 id="updating-mis-in-cycles">Updating MIS in Cycles</h2> <p>Now that we have the code to recalculate probabilities, we’re almost done. Just one slight issue: we start at some surface to shoot a ray, but once we’ve intersected something else and need the MIS calculations, we’ve lost the normal information of the original surface. To resolve this, we add a struct member called <code class="language-plaintext highlighter-rouge">mis_origin_n</code> to store the normal when we first prepare things for MIS:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\integrator\shade_surface.h</span>
<span class="n">INTEGRATOR_STATE_WRITE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mis_ray_pdf</span><span class="p">)</span> <span class="o">=</span> <span class="n">bsdf_pdf</span><span class="p">;</span>
<span class="n">INTEGRATOR_STATE_WRITE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mis_ray_t</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
<span class="n">INTEGRATOR_STATE_WRITE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mis_origin_n</span><span class="p">)</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">N</span><span class="p">;</span>
<span class="n">INTEGRATOR_STATE_WRITE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">min_ray_pdf</span><span class="p">)</span> <span class="o">=</span> <span class="n">fminf</span><span class="p">(</span>
    <span class="n">bsdf_pdf</span><span class="p">,</span> <span class="n">INTEGRATOR_STATE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">min_ray_pdf</span><span class="p">));</span>
</code></pre></div></div> <p>Here, <code class="language-plaintext highlighter-rouge">sd</code> contains information about the current shading point, so we want to hold onto the normal for later. Now we have all the data we need to recalculate our PDFs. In the last post, I mentioned that I was going to be updating some PDF functions, but then I felt like it was actually cleaner to instead update the functions that were actually performing the MIS. These functions included:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">integrate_light()</code> for light sources</li> <li> <code class="language-plaintext highlighter-rouge">integrate_surface_emission()</code> for emissive triangles</li> <li> <code class="language-plaintext highlighter-rouge">integrate_distant_lights()</code> for sun lights</li> <li> <code class="language-plaintext highlighter-rouge">integrator_eval_background_shader()</code> for background lights</li> </ul> <p>The pattern is pretty much the same for each of these functions. While the MIS weighting is performed, we readjust the <code class="language-plaintext highlighter-rouge">LightSample</code>’s PDF to account for the light tree if it’s being used:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\integrator\shade_light.h</span>
<span class="cm">/* MIS weighting. */</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">path_flag</span> <span class="o">&amp;</span> <span class="n">PATH_RAY_MIS_SKIP</span><span class="p">))</span> <span class="p">{</span>
<span class="cm">/* multiple importance sampling, get regular light pdf,
    * and compute weight with respect to BSDF pdf */</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">mis_ray_pdf</span> <span class="o">=</span> <span class="n">INTEGRATOR_STATE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mis_ray_pdf</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">use_light_tree</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">float3</span> <span class="n">N</span> <span class="o">=</span> <span class="n">INTEGRATOR_STATE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mis_origin_n</span><span class="p">);</span>
    <span class="n">ls</span><span class="p">.</span><span class="n">pdf</span> <span class="o">*=</span> <span class="n">light_tree_pdf</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">ray_P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="o">~</span><span class="n">ls</span><span class="p">.</span><span class="n">lamp</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">mis_weight</span> <span class="o">=</span> <span class="n">light_sample_mis_weight_forward</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">mis_ray_pdf</span><span class="p">,</span> <span class="n">ls</span><span class="p">.</span><span class="n">pdf</span><span class="p">);</span>
<span class="n">light_eval</span> <span class="o">*=</span> <span class="n">mis_weight</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Write to render buffer. */</span>
<span class="k">const</span> <span class="n">float3</span> <span class="n">throughput</span> <span class="o">=</span> <span class="n">INTEGRATOR_STATE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">throughput</span><span class="p">);</span>
<span class="n">kernel_accum_emission</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">throughput</span> <span class="o">*</span> <span class="n">light_eval</span><span class="p">,</span> <span class="n">render_buffer</span><span class="p">,</span> <span class="n">ls</span><span class="p">.</span><span class="n">group</span><span class="p">);</span>
</code></pre></div></div> <p>In this case, <code class="language-plaintext highlighter-rouge">ray_P</code> represents the origin of the ray (aka the position of our shading point), but that’s something that’s already being stored in the integrator state.</p> <h2 id="closing-thoughts">Closing Thoughts</h2> <p>Overall, this week was a bit heavier on the debugging side again. I think I made too many modifications at the beginning again, which made it a lot harder to debug some things down the line. I had to jump between commits a few times just to make some sanity checks! Thankfully, it seems to have worked out for now…</p> <p>On the non-MIS side of things, the debugging allowed me to catch some more obvious mistakes which improved the importance heuristics a lot. These things were actually more related to some topics I’ve already posted about, so I’ll try to just edit the existing ones instead of creating new posts. The main contributions were:</p> <ul> <li>Remodifying some of the triangle sampling logic</li> <li>Adjusting the distant light importance heuristic</li> </ul> <p>Sometimes it’s a painful process, but as I mentioned before, it’s extremely rewarding to see things work out! Again, I’m still using some special test cases, but some scenes are already being rendered in less time (with adaptive sampling) compared to the original method. The last thing I haven’t tested yet is environment HDRIs. Hopefully it goes smoothly, but I’m sure I’ll run into something that can at least be improved.</p> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Jeffrey Liu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: December 27, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-publications",title:"publications",description:"publications by categories in reversed chronological order.",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"nav-blog-posts",title:"blog posts",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-personal-projects",title:"personal projects",description:"Most of my work in the past few years has been related to work or research, so I haven&#39;t found too much time for personal projects recently. The projects listed here are mostly old or coursework related, so I&#39;m not sharinig them because I think they&#39;re impressive, but because I think they still represent things I&#39;m interested in. Hoping to find time to add to this in the near future!",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-curriculum-vitae",title:"curriculum vitae",description:"This page just has some basic information. For a (slightly more) complete research and work CV, please download the attached PDF.",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"post-reflecting-on-gsoc-2022",title:"Reflecting on GSoC 2022",description:"A three month late reflection on GSoC 2022.",section:"Posts",handler:()=>{window.location.href="/blog/2022/gsoc-conclusion/"}},{id:"post-weighted-reservoir-sampling-for-adaptive-splitting",title:"Weighted Reservoir Sampling for Adaptive Splitting",description:"The Cycles version of adaptive splitting.",section:"Posts",handler:()=>{window.location.href="/blog/2022/adaptive-splitting/"}},{id:"post-correcting-for-multiple-importance-sampling",title:"Correcting for Multiple Importance Sampling",description:"Fixes to the PDF calculations to adjust for the light tree sampling.",section:"Posts",handler:()=>{window.location.href="/blog/2022/light-tree-mis/"}},{id:"post-adding-more-light-types",title:"Adding More Light Types",description:"How different light types in Blender are used in the many lights sampling algorithm.",section:"Posts",handler:()=>{window.location.href="/blog/2022/more-light-types/"}},{id:"post-supporting-point-lights",title:"Supporting Point Lights",description:"A more detailed technical explanation of supporting the many lights algorithm for point lights in Blender.",section:"Posts",handler:()=>{window.location.href="/blog/2022/blender-point-lights/"}},{id:"post-motivating-many-lights-sampling-with-a-light-tree",title:"Motivating Many Lights Sampling with a Light Tree",description:"An introduction to the many lights sampling algorithm and how I plan to implement it in Blender.",section:"Posts",handler:()=>{window.location.href="/blog/2022/motivating-light-trees/"}},{id:"post-introduction-to-gsoc-with-blender",title:"Introduction to GSoC with Blender",description:"A self-introduction and my plans for this series.",section:"Posts",handler:()=>{window.location.href="/blog/2022/gsoc-introduction/"}},{id:"news-our-book-chapter-on-ray-tracing-large-voxel-scenes-has-been-published-as-part-of-gpu-zen-3-https-www-amazon-com-gpu-zen-advanced-rendering-techniques-dp-b0dnxnm14k-if-you-39-re-looking-for-some-reading-over-winter-break-please-check-it-out-a-big-thanks-to-all-of-the-editors-involved",title:"Our book chapter on ray tracing large voxel scenes has been published as...",description:"",section:"News"},{id:"projects-ascii-rasterizer",title:"ASCII Rasterizer",description:"Interactive (CPU) software rasterizer with CLI display.",section:"Projects",handler:()=>{window.location.href="/projects/ascii-rasterizer/"}},{id:"projects-hand-tracker",title:"Hand Tracker",description:"Stereo hand tracker with multi-CNN prediction and triplane fusion.",section:"Projects",handler:()=>{window.location.href="/projects/hand-tracking/"}},{id:"projects-holography",title:"Holography",description:"Lab on holographic recording and reconstruction.",section:"Projects",handler:()=>{window.location.href="/projects/holography/"}},{id:"projects-raycast-engine",title:"Raycast Engine",description:"Implementation of raycasting and floorcasting in Python.",section:"Projects",handler:()=>{window.location.href="/projects/python-raycaster/"}},{id:"projects-style-share",title:"Style Share",description:"Web-based 3D engine with neural stylization post processing.",section:"Projects",handler:()=>{window.location.href="/projects/style-share/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%6A%6C%69%75%31%37%39@%69%6C%6C%69%6E%6F%69%73.%65%64%75","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/Jebbly","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/jeffrey-liu-604","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>