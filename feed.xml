<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://jebbly.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://jebbly.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-06-08T19:42:58+00:00</updated><id>https://jebbly.github.io/feed.xml</id><title type="html">blank</title><subtitle>Jeffrey Liu&apos;s Personal Website. </subtitle><entry><title type="html">Reflecting on GSoC 2022</title><link href="https://jebbly.github.io/blog/2022/gsoc-conclusion/" rel="alternate" type="text/html" title="Reflecting on GSoC 2022"/><published>2022-12-19T00:00:00+00:00</published><updated>2022-12-19T00:00:00+00:00</updated><id>https://jebbly.github.io/blog/2022/gsoc-conclusion</id><content type="html" xml:base="https://jebbly.github.io/blog/2022/gsoc-conclusion/"><![CDATA[<p>I was planning on writing this post a lot sooner, but work for the fall semester hit me really fast. Anyways, now that GSoC is over (although, it’s already been over for more than 3 months), you can read my final report <a href="https://wiki.blender.org/wiki/User:JeffreyLiu/GSoC2022/FinalReport">here</a>. Seeing the eye candy at the end was really fun! Here’s my favorite result from GSoC, which is also shown in the report:</p> <p>Here’s the render after 30 seconds of rendering using the master branch (left), compared to 30 seconds of rendering on the GSoC branch (right):</p> <img-comparison-slider> <figure slot="first"> <picture> <img src="/assets/img/blog/gsoc/attic-original.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure slot="second"> <picture> <img src="/assets/img/blog/gsoc/attic-mls.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </img-comparison-slider> <p>There’s still some noise, but it’s a lot better. Since I’m also writing this extremely late, I get to say that other people have picked up the work and got it merged into master!</p> <h2 id="closing-thoughts">Closing Thoughts</h2> <p>I’ve probably said it many times already, so I’ll try to keep it short. All I can say is that Google Summer of Code was everything I wanted and expected it to be and more. Blender basically defined me as a teenager so being able to contribute to it has felt incredible. I’m really thankful for everyone who took the time to read my posts, upload test scenes, provide advice/resources, and contribute code. The whole process has taught me a lot and helped me develop more confidence as a computer scientist/programmer. Every company I’ve interviewed at this semester has also asked me about working with Blender, so I think it’s safe to say that it’s also helped me with my job search.</p> <p>Moving on, although the main parts of the code have already been merged into master, there are still plenty of bugs and improvements to be worked on. I’ll be working on those from now on, and after those are done, hopefully I can also help out with another Blender/Cycles project!</p>]]></content><author><name></name></author><category term="gsoc-2022"/><category term="path-tracing"/><summary type="html"><![CDATA[A three month late reflection on GSoC 2022.]]></summary></entry><entry><title type="html">Weighted Reservoir Sampling for Adaptive Splitting</title><link href="https://jebbly.github.io/blog/2022/adaptive-splitting/" rel="alternate" type="text/html" title="Weighted Reservoir Sampling for Adaptive Splitting"/><published>2022-08-11T00:00:00+00:00</published><updated>2022-08-11T00:00:00+00:00</updated><id>https://jebbly.github.io/blog/2022/adaptive-splitting</id><content type="html" xml:base="https://jebbly.github.io/blog/2022/adaptive-splitting/"><![CDATA[<p><strong>NOTE:</strong> This branch has finally been merged into master (yay!). It seems like most of the work below was reverted due to its substantially larger overhead, but I’m leaving this post here because I still think it’s an interesting idea to explore.</p> <p>As the algorithm has improved, we’ve found that the importance heuristic alone can only go so far. For example, here are some obvious artifacts in a test scene made by Alaska (special thanks for so much debugging help!):</p> <figure> <picture> <img src="/assets/img/blog/gsoc/no-splitting-issue.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Here, that dark region is where the importance heuristic thinks that the area light will be a heavy contributor, but it’s actually cutoff already. It’s especially extreme at low samples, but just in general, it’s something we need to fix.</p> <p>The original paper doesn’t really discuss any issues of this nature, but it does heavily emphasize that the adaptive splitting is an essential part of their work. The point of adaptive spltting is that sometimes, the light tree node’s variance is pretty high, so it’s safer to just sample from both the left and right child in those cases. However, the caveat here is that Cycles is structured such that the direct light sampling is expected to use a single light at a time, so we can’t exactly just continue adding samples.</p> <h2 id="potential-solutions">Potential Solutions</h2> <h3 id="resampled-importance-sampling">Resampled Importance Sampling</h3> <p>The first proposed solution was to implement resampled importance sampling (RIS). This is a topic that I’ve only briefly skimmed over so far, and also not our final solution, so I’ll keep this section brief. The general idea is that we’ll do the adaptive splitting, but we keep track of all the samples in a list. Once we’ve populated our list, we can use a more refined computation (e.g. computing an actual <code class="language-plaintext highlighter-rouge">LightSample</code>) to weight each entry when we’re choosing our final sample. This method kind of allows us to consider the proposed samples from adaptive splitting, and would be especially useful in cases like above where the original importance heuristic is off.</p> <p>There’s a bit of nuance related to the functions used, the target distribution, and the size of the list. I’m not really going to get into the details here, but if you’re interested, the paper I referenced was <a href="https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1662&amp;context=etd">“Importance Resampling for Global Illumination”</a> by Justin Talbot. In any case, the downside to this approach is that it generally assumes a fixed list size. However, we never really know how many adaptive splitting samples we’ll be getting, and it’s not the best in terms of memory usage either. It also means we’ll have to do another pass through the list once we’re done traversing the tree.</p> <h3 id="weighted-reservoir-sampling">Weighted Reservoir Sampling</h3> <p>Fortunately, I happened to come across another technique called “weighted reservoir sampling” while I was looking into NVIDIA’s ReSTIR algorithm. It also just so happens that there’s a chapter about it in RTGII. It’s actually able to select a reservoir with an arbitrary number of samples, but we’re only concerned with the special case where \(K = 1\) here. The idea of this technique is actually pretty simple, and kinda similar to the first technique. The main difference is that we’re selecting a single sample out of an arbitrary stream of samples.</p> <p>So for our case, think of our light tree traversal with adaptive splitting. When we hit our first sample, we hold onto it with probability \(w_1 / w_1 = 1\). Here we compute the weights using some slightly better heuristics, such as actually taking a <code class="language-plaintext highlighter-rouge">LightSample</code>. Then, assuming that our traversal has split a few times, we’ll eventually encounter another candidate sample. Now we hold on to second sample with probability \(w_2 / (w_1 + w_2)\), and otherwise we stick with our current sample. We continue this process until we complete traversal or whatnot.</p> <p>After \(j\) samples, the probability of selecting the \(i\)-th sample is:</p> \[\frac{w_i}{\sum_{k = 1}^j w_k}.\] <p>There are a few big advantages to this approach, when our reservoir is size \(N = 1\):</p> <ul> <li>The memory usage is much better because we only need to keep track of the currently selected light and the accumulated weight of the samples;</li> <li>The algorithm works with a stream of samples, so we don’t need to worry about the specific number of adaptive splitting samples, and we can also compute it while we’re traversing the light tree.</li> </ul> <h2 id="pdf-considerations">PDF Considerations</h2> <p>Overall, the weighted reservoir sampling seems like a great solution for adaptive splitting, but the elephant in the room is how to properly calculate PDFs now. In this section, I’ll describe what we can do to keep our estimator unbiased.</p> <h3 id="direct-light-sampling">Direct Light Sampling</h3> <p>So ignoring multiple importance sampling for now, let’s assume that we’re trying to approximate the following integral:</p> \[F = \int_S f(x) \,dx.\] <p>In this case, our standard Monte Carlo estimator looks like the following:</p> \[F_N = \frac{1}{N} \sum_{i = 1}^N \frac{f(X_i)}{p(X_i)}.\] <p>However, in the case of weighted reservoir sampling, calculating the true probability of selecting \(p(X_i)\) is pretty tricky. This is because the stream of candidates varies based on how we traverse the light tree, which in turn affects the weights. As a simple example, suppose we have the following tree where we split at the root:</p> <figure> <picture> <img src="/assets/img/blog/gsoc/example-tree.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>The values are used as the relative weights, e.g. there’s a \(2/(2 + 3)\) probability of selecting \(2\) from the left child. Since we’ve split, we select an element from both children, and then compare the two elements again. Let \(X_1, X_2\) be the random variables representing the left and right child respectively, and \(X_F\) be the final sample. Then we have:</p> \[\begin{aligned} \mathbb{P}(X_F = 2) &amp; = \mathbb{P}\left(X_F = 2 \mid (X_1 = 2 \cap X_2 = 4)\right) \cdot \mathbb{P}(X_1 = 2 \cap X_2 = 4) \\ &amp; \quad + \mathbb{P}\left(X_F = 2 \mid (X_1 = 2 \cap X_2 = 5)\right) \cdot \mathbb{P}(X_1 = 2 \cap X_2 = 5) \\ &amp; = \mathbb{P}\left(X_F = 2 \mid (X_1 = 2 \cap X_2 = 4)\right) \cdot \mathbb{P}(X_1 = 2) \cdot \mathbb{P}(X_2 = 4) \\ &amp; \quad + \mathbb{P}\left(X_F = 2 \mid (X_1 = 2 \cap X_2 = 5)\right) \cdot \mathbb{P}(X_1 = 2) \cdot \mathbb{P}(X_2 = 5) \\ &amp; = \frac{2}{6} \cdot \frac{2}{5} \cdot \frac{4}{9} + \frac{2}{7} \cdot \frac{2}{5} \cdot \frac{5}{9} \\ &amp; = \cdots \end{aligned}\] <p>The main idea is that this computation, even for this simple example, can be quite complicated. However, the proposed solution is to adjust our estimator such that \(p(X_i)\) is equal to the probability of including \(X_i\) as a candidate sample times the probability of selecting \(X_i\) as our final sample.</p> <p>I’m still having some difficulty formalizing this, but consider the use of this estimator for the case of \(2\). There are two cases where \(2\) is selected as our final sample, with the corresponding probabilities:</p> <ol> <li>2 is selected from the left (\(2/5\)) and 4 is selected from the right (\(4/9\)) <ul> <li>2 is selected out of the list (\(2/6\))</li> </ul> </li> <li>2 is selected from the left (\(2/5\)) and 5 is selected from the right (\(5/9\)) <ul> <li>2 is selected out of the list (\(2/7\))</li> </ul> </li> </ol> <p>Intuitively speaking, if we look at the specific case for \(2 / p(X)\), we would have the following frequencies:</p> \[\left(\frac{2}{5} \cdot \frac{4}{9} \cdot \frac{2}{6} \right) \cdot \frac{2}{2/5 \cdot 2/6} + \left(\frac{2}{5} \cdot \frac{5}{9} \cdot \frac{2}{7} \right) \cdot \frac{2}{2/5 \cdot 2/7} = \frac{4}{9} \cdot 2 + \frac{5}{9} \cdot 2 = 2.\] <p>This should extend to the other values, which would imply that our estimator remains unbiased. This should always work because we guarantee the invariant:</p> \[\sum_{i = 1}^n p_i = 1,\] <p>where \(n\) is the total number of lists containing some sample \(X\) and \(p_i\) is the probability that the rest of the list \(i\) is constructed. Furthermore, my guess is that this will extend cleanly to the continuous case, although this is also where I’m having some trouble formalizing things.</p> <h2 id="closing-thoughts">Closing Thoughts</h2> <p>As mentioned at the top, there were a few reasons why this idea didn’t pan out:</p> <ol> <li>It was hard to convince that this estimator would remain unbiased;</li> <li>Regardless of if it remained or not, each sample was taking too much time to compute.</li> </ol> <p>But it was a really interesting idea! I also got to talk more about it with Chris Wyman (really cool person at NVIDIA who wrote a chapter about Weighted Reservoir Sampling in Raytracing Gems II) at SIGGRAPH 2022. That might deserve a post of its own, but the TLDR is that I volunteered there, met a lot of cool people, including Ron Roosendaal himself, and had lots of fun!</p>]]></content><author><name></name></author><category term="gsoc-2022"/><category term="path-tracing"/><summary type="html"><![CDATA[The Cycles version of adaptive splitting.]]></summary></entry><entry><title type="html">Correcting for Multiple Importance Sampling</title><link href="https://jebbly.github.io/blog/2022/light-tree-mis/" rel="alternate" type="text/html" title="Correcting for Multiple Importance Sampling"/><published>2022-07-09T00:00:00+00:00</published><updated>2022-07-09T00:00:00+00:00</updated><id>https://jebbly.github.io/blog/2022/light-tree-mis</id><content type="html" xml:base="https://jebbly.github.io/blog/2022/light-tree-mis/"><![CDATA[<p>If you recall from my second post, importance sampling is the name of the game, but I actually kind of omitted something from that chapter. Notice that there’s actually two main terms in the integrand of the rendering equation:</p> \[L_o(p, \omega_o) = L_e(p, \omega_o) + \int_\Omega f(x, \omega_i, \omega_o) L_i(p, \omega_i) \,d \omega_i\] <p>So it’s great if we’re looking for light sources that are really strong and contribute a lot to the \(L_i\) term, but there’s a slight issue. For example, consider a scenario where we’re looking across a mirror from a very shallow angle and there’s a really strong light source that’s directly above the mirror. Turns out, that light source isn’t really contributing much to what we’re seeing at all! The issue is that the BSDF term also plays a role in our integrand, and we’re going to have a lot of trouble if we keep focusing our samples towards a strong light source and isn’t contributing all that much. Thankfully, people have come up with a pretty good solution: multiple importance sampling!</p> <h2 id="multiple-importance-sampling">Multiple Importance Sampling</h2> <p>The idea of multiple importance sampling is to take some samples based on both terms of the integrand (in this case, \(f\) and \(L_i\)). As PBRT mentions, we can’t just define two separate estimators that each use a different sampling distribution because the variance is additive. Instead, we use the estimator given by:</p> \[\frac{1}{n_f} \sum_{i = 1}^{n_f} \frac{f(X_i) g(X_i) w_f(X_i)}{p_f(X_i)} + \frac{1}{n_g} \sum_{i = 1}^{n_g} \frac{f(X_i) g(X_i) w_g(X_i)}{p_g(X_i)}\] <p>Here, \(n_f, n_g\) are the number of samples used from the \(p_f, p_g\) distributions respectively. The \(w_f\) and \(w_g\) terms correspond to a weighting heuristic (that should sum to 1). It’s relative straightforward to verify this estimator is still unbiased:</p> \[\begin{aligned} \mathbb{E}[F] &amp;= \mathbb{E}\left[\frac{1}{n_f} \sum_{i = 1}^{n_f} \frac{f(X_i) g(X_i) w_f(X_i)}{p_f(X_i)} + \frac{1}{n_g} \sum_{i = 1}^{n_g} \frac{f(X_i) g(X_i) w_g(X_i)}{p_g(X_i)} \right] \\ &amp;= \frac{1}{n_f} (n_f) \mathbb{E}\left[ \frac{f(X_i) g(X_i) w_f(X_i)}{p_f(X_i)} \right] + \frac{1}{n_g} (n_g) \mathbb{E}\left[ \frac{f(X_i) g(X_i) w_g(X_i)}{p_g(X_i)} \right] \\ &amp;= \int \frac{f(x) g(x) w_f(x)}{p_f(x)} p_f((x) \,dx + \int \frac{f(x) g(x) w_g(x)}{p_g(x)} p_g(x) \,dx \\ &amp;= \int f(x) g(x) w_f(x) \,dx + \int f(x) g(x) w_g(x) \,dx \\ &amp;= \int f(x) g(x) (w_f(x) + w_g(x)) \,dx \\ &amp; = \int f(x) g(x) \,dx. \end{aligned}\] <p>In Cycles, each pass of <code class="language-plaintext highlighter-rouge">integrator_shade_surface()</code> actually takes two samples: one for direct lighting (only sampling light sources) and one for indirect lighting (sampling based on the BSDF). The weighting used is the power heuristic, which simplifies slightly because \(n_f = n_g = n\) in this case:</p> \[w_f(x_i) = \frac{(n_f p_f(x_i))^2}{(n_f p_f(x_i))^2 + (n_g p_g(x_i))^2} = \frac{n^2 p_f(x_i)^2}{n^2(p_f(x_i)^2 + p_g(x_i)^2)} = \frac{p_f(x_i)^2}{p_f(x_i)^2 + p_g(x_i)^2}.\] <p>The same calculation can be done for \(w_g(x_i)\). The important thing to note here is that, in order to calculate the proper power heuristic for a given sample, we actually need to compute the direct light PDF as well as the indirect light PDF. We’re not going to worry too much about the indirect light PDF because we’re not changing anything there, so the rest of this post is focused on how the direct light PDF needs to be adjusted.</p> <h2 id="many-lights-sampling-pdfs">Many Lights Sampling PDFs</h2> <p>In the default implementation where direct lighting is sampled based on the light distribution (as I’ve mentioned many times before), it’s pretty simple to compute the PDF. In fact, most of it is already pre-computed during construction:</p> <ul> <li>Light sources have a <code class="language-plaintext highlighter-rouge">1 / num_lights</code> probability of being chosen</li> <li>Triangles have an <code class="language-plaintext highlighter-rouge">area / total_area</code> (where <code class="language-plaintext highlighter-rouge">total_area</code> is the total area of all the triangles) probability of being chosen</li> <li>If there are both light sources and triangles involved, divide those probabilities in half (because either a light or a triangle is chosen)</li> </ul> <p>When we sample from the BSDF and we happen to intersect with a light source, we basically already have all this information. The only additional computation to be made is if we need to calculate a specific triangle’s area.</p> <p>Things get a little complicated, to say the least, when it comes to sampling from the light tree. The main issue is that the direct light sampling distribution is position-dependent. As a result, there isn’t much information to compute during construction, and we need to calculate the probability of sampling that light source from whatever point we were sampling from. To review how we sample light sources:</p> <ul> <li>First, we sample either from the light tree or the distant light group (probability based on relative energies)</li> <li>If we choose the light tree, we traverse down the binary tree (according to their relative importances) until we hit a leaf node <ul> <li>At a leaf node, we sample based off of a CDF constructed from the relative importances of the light sources in the leaf</li> </ul> </li> <li>If we choose the distant light group, we immediately sample based off of a CDF constructed from the relative importances</li> </ul> <h3 id="a-brief-interlude">A Brief Interlude</h3> <p>Before we even get to all those PDF calculations, the more pressing question is how to actually find the light source from the distant group or the light tree. It’s easy to start from the top and pick a light source in the light tree, but what about the converse? Given some light source, how do we know where it would be in the light tree? The same issue holds for the distant lights group.</p> <p>My first idea was to attach another member variable to the <code class="language-plaintext highlighter-rouge">KernelLight</code> struct, which would point back to the corresponding index in the light tree emitters array or the distant lights array. Something similar would need to be done for triangles. The issue with this approach is that the <code class="language-plaintext highlighter-rouge">KernelLight</code> struct is already perfectly aligned to 16 bytes, so adding another member variable (4 bytes for an int) would also require an additional 12 bytes of padding for alignment. Furthermore, not every triangle is an emitter, so it would be holding empty information. Lastly, this member is also useless if the light tree isn’t being used.</p> <p>My next idea was to instead creating separate arrays which would store their corresponding indices in the light tree setup. For example, if we’re at a triangle with index 0, then we query the triangle array at index 0 for its index in <code class="language-plaintext highlighter-rouge">light_tree_emitters</code>. We do this for both light sources and triangles, but the corresponding indices for distant lights will index into the distant lights array:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">KERNEL_DATA_ARRAY</span><span class="p">(</span><span class="n">uint</span><span class="p">,</span> <span class="n">light_to_tree</span><span class="p">)</span>
<span class="n">KERNEL_DATA_ARRAY</span><span class="p">(</span><span class="n">uint</span><span class="p">,</span> <span class="n">triangle_to_tree</span><span class="p">)</span>
</code></pre></div></div> <p>You may have noticed that this array needs to match the size of all the triangles, emissive or not, in order to work. The tradeoff here is that we’re using up a bit of unnecessary memory, but the lookup times are fast and constant. Now that we know where we are in the light tree, we can start worrying about how to calculate the probability of reaching that location.</p> <h3 id="light-tree-group">Light Tree Group</h3> <p>The harder case is the light tree because the direct light sampling method relies on traversing down a binary tree before arriving at some light source; in the case of sampling a light from the indirect light sampling, we’re given a specific light source and asked to calculate the probability of sampling it. To do this, we’ll need a way to go back up the tree in order to compare importances at each level. The easiest way to do that is to update our <code class="language-plaintext highlighter-rouge">LightTreeNode</code> and <code class="language-plaintext highlighter-rouge">LightTreeEmitter</code> structs to store its parent index. It works out perfectly because our structs already had some extra padding anyways:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\types.h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">KernelLightTreeNode</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="cm">/* Parent. */</span>
  <span class="kt">int</span> <span class="n">parent_index</span><span class="p">;</span>

  <span class="cm">/* Padding. */</span>
  <span class="kt">int</span> <span class="n">pad1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">KernelLightTreeNode</span><span class="p">;</span>
<span class="n">static_assert_align</span><span class="p">(</span><span class="n">KernelLightTreeNode</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">KernelLightTreeEmitter</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="cm">/* Parent. */</span>
  <span class="kt">int</span> <span class="n">parent_index</span><span class="p">;</span>
<span class="p">}</span> <span class="n">KernelLightTreeEmitter</span><span class="p">;</span>
<span class="n">static_assert_align</span><span class="p">(</span><span class="n">KernelLightTreeEmitter</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</code></pre></div></div> <p>This means we also need to update our light tree construction too. When we’re finishing up construction during <code class="language-plaintext highlighter-rouge">LightTree::flatten_tree</code>, we attach an extra argument to indicate the index of the parent:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\scene\light_tree.cpp</span>
<span class="kt">int</span> <span class="n">LightTree</span><span class="o">::</span><span class="n">flatten_tree</span><span class="p">(</span><span class="k">const</span> <span class="n">LightTreeBuildNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">int</span> <span class="n">current_index</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
  <span class="n">offset</span><span class="o">++</span><span class="p">;</span>

  <span class="cm">/* If current node contains lights, then it is a leaf node.
   * Otherwise, create interior node and children recursively. */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_lights</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">first_prim_index</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">first_prim_index</span><span class="p">;</span>
    <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">num_lights</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">num_lights</span><span class="p">;</span>
    <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">is_leaf_node</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">num_lights</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">is_leaf_node</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="cm">/* The first child is located directly to the right of the parent. */</span>
    <span class="n">flatten_tree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">offset</span><span class="p">,</span> <span class="n">current_index</span><span class="p">);</span>
    <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">second_child_index</span> <span class="o">=</span> <span class="n">flatten_tree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">offset</span><span class="p">,</span> <span class="n">current_index</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">current_index</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Note that the first call to this function passes an argument of <code class="language-plaintext highlighter-rouge">-1</code> to the <code class="language-plaintext highlighter-rouge">parent</code> parameter, so we know when we’re at the root. Now that we have a way to traverse up the tree, we’re ready to try calculating some probabilities! The first step is to find the probability of actually sampling from the light tree, which is its relative importance compared to the distant lights:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light_tree.h</span>
<span class="n">ccl_device</span> <span class="kt">float</span> <span class="nf">light_tree_pdf</span><span class="p">(</span><span class="n">KernelGlobals</span> <span class="n">kg</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">P</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">N</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">prim</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">float</span> <span class="n">distant_light_importance</span> <span class="o">=</span> <span class="n">light_tree_distant_light_importance</span><span class="p">(</span>
      <span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distant_lights</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">light_tree_importance</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distribution</span> <span class="o">&gt;</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distant_lights</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">ccl_global</span> <span class="n">KernelLightTreeNode</span> <span class="o">*</span><span class="n">kroot</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_tree_nodes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">light_tree_importance</span> <span class="o">=</span> <span class="n">light_tree_cluster_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">kroot</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="kt">float</span> <span class="n">total_group_importance</span> <span class="o">=</span> <span class="n">light_tree_importance</span> <span class="o">+</span> <span class="n">distant_light_importance</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">total_group_importance</span> <span class="o">!=</span> <span class="mf">0.0f</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">pdf</span> <span class="o">=</span> <span class="n">light_tree_importance</span> <span class="o">/</span> <span class="n">total_group_importance</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>Next, we find the probability of actually selecting the light when we’re at the leaf node:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light_tree.h</span>
<span class="n">ccl_device</span> <span class="kt">float</span> <span class="nf">light_tree_pdf</span><span class="p">(</span><span class="n">KernelGlobals</span> <span class="n">kg</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">P</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">N</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">prim</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">emitter</span> <span class="o">=</span> <span class="p">(</span><span class="n">prim</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">triangle_to_tree</span><span class="p">,</span> <span class="n">prim</span><span class="p">)</span> <span class="o">:</span> <span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_to_tree</span><span class="p">,</span> <span class="o">~</span><span class="n">prim</span><span class="p">);</span>
  <span class="n">ccl_global</span> <span class="k">const</span> <span class="n">KernelLightTreeEmitter</span><span class="o">*</span> <span class="n">kemitter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_tree_emitters</span><span class="p">,</span>
                                                                         <span class="n">emitter</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">kemitter</span><span class="o">-&gt;</span><span class="n">parent_index</span><span class="p">;</span>
  <span class="n">ccl_global</span> <span class="k">const</span> <span class="n">KernelLightTreeNode</span><span class="o">*</span> <span class="n">kleaf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_tree_nodes</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>

  <span class="cm">/* First, we find the probability of selecting the primitive out of the leaf node. */</span>
  <span class="kt">float</span> <span class="n">total_importance</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">emitter_importance</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kleaf</span><span class="o">-&gt;</span><span class="n">num_prims</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">prim</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">kleaf</span><span class="o">-&gt;</span><span class="n">child_index</span><span class="p">;</span> <span class="cm">/* At a leaf node, the negative value is the index into first prim. */</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">importance</span> <span class="o">=</span> <span class="n">light_tree_emitter_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">prim</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">emitter</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">emitter_importance</span> <span class="o">=</span> <span class="n">importance</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">total_importance</span> <span class="o">+=</span> <span class="n">importance</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">pdf</span> <span class="o">*=</span> <span class="n">emitter_importance</span> <span class="o">/</span> <span class="n">total_importance</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>We use our newly created arrays to find out the position in the <code class="language-plaintext highlighter-rouge">light_tree_emitters</code>, and we then query the <code class="language-plaintext highlighter-rouge">parent_index</code> to find which leaf node contains this emitter. Our leaf node contains all the information we need about the primitives it contains, so we iterate through and find our specific primitive’s relative weight. Next, we want to find the probability of actually traversing to this leaf node:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light_tree.h</span>
<span class="n">ccl_device</span> <span class="kt">float</span> <span class="nf">light_tree_pdf</span><span class="p">(</span><span class="n">KernelGlobals</span> <span class="n">kg</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">P</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">N</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">prim</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="cm">/* Next, we find the probability of traversing to that leaf node. */</span>
  <span class="kt">int</span> <span class="n">child_index</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
  <span class="n">parent</span> <span class="o">=</span> <span class="n">kleaf</span><span class="o">-&gt;</span><span class="n">parent_index</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">ccl_global</span> <span class="n">KernelLightTreeNode</span> <span class="o">*</span><span class="n">kparent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_tree_nodes</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">left_index</span> <span class="o">=</span> <span class="n">parent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">right_index</span> <span class="o">=</span> <span class="n">kparent</span><span class="o">-&gt;</span><span class="n">child_index</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">ccl_global</span> <span class="n">KernelLightTreeNode</span> <span class="o">*</span><span class="n">kleft</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_tree_nodes</span><span class="p">,</span> <span class="n">left_index</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">ccl_global</span> <span class="n">KernelLightTreeNode</span> <span class="o">*</span><span class="n">kright</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_tree_nodes</span><span class="p">,</span> <span class="n">right_index</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">float</span> <span class="n">left_importance</span> <span class="o">=</span> <span class="n">light_tree_cluster_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">kleft</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">right_importance</span> <span class="o">=</span> <span class="n">light_tree_cluster_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">kright</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">left_probability</span> <span class="o">=</span> <span class="n">left_importance</span> <span class="o">/</span> <span class="p">(</span><span class="n">left_importance</span> <span class="o">+</span> <span class="n">right_importance</span><span class="p">);</span>

    <span class="cm">/* If the child index matches the left index, then we must've traversed left, otherwise right. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left_index</span> <span class="o">==</span> <span class="n">child_index</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pdf</span> <span class="o">*=</span> <span class="n">left_probability</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">pdf</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">left_probability</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">child_index</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">kparent</span><span class="o">-&gt;</span><span class="n">parent_index</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">pdf</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>At any node, we go up to the parent node so that we can compare the children. We also keep track of the child node’s index, so we can actually tell whether it was the left or right node. We continue this until our parent index reaches <code class="language-plaintext highlighter-rouge">-1</code>, which indicates that we’ve already hit the root. At this point, we’ve accounted for everything:</p> <ul> <li>The probability of sampling the light tree over the distant lights;</li> <li>The probability of sampling the specific leaf node containing our primitive;</li> <li>The probability of sampling our primitive out of all the primitives in the leaf.</li> </ul> <p>This is the entire process of sampling the light tree, so we can finally return our computed PDF!</p> <h3 id="distant-light-group">Distant Light Group</h3> <p>The easy case to compute the PDF is the distant lights group. All we have to do is calculate the importance of that specific light, and then divide that by the total importance of the distant lights. We also need to multiply by the probability of sampling from the distant light group and not the light tree:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light_tree.h</span>
<span class="n">ccl_device</span> <span class="kt">float</span> <span class="nf">distant_lights_pdf</span><span class="p">(</span><span class="n">KernelGlobals</span> <span class="n">kg</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">P</span><span class="p">,</span> <span class="k">const</span> <span class="n">float3</span> <span class="n">N</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">prim</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">float</span> <span class="n">distant_light_importance</span> <span class="o">=</span> <span class="n">light_tree_distant_light_importance</span><span class="p">(</span>
      <span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distant_lights</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">light_tree_importance</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distribution</span> <span class="o">&gt;</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distant_lights</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">ccl_global</span> <span class="n">KernelLightTreeNode</span> <span class="o">*</span><span class="n">kroot</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_tree_nodes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">light_tree_importance</span> <span class="o">=</span> <span class="n">light_tree_cluster_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">kroot</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="kt">float</span> <span class="n">total_group_importance</span> <span class="o">=</span> <span class="n">light_tree_importance</span> <span class="o">+</span> <span class="n">distant_light_importance</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">total_group_importance</span> <span class="o">!=</span> <span class="mf">0.0f</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">pdf</span> <span class="o">=</span> <span class="n">distant_light_importance</span> <span class="o">/</span> <span class="n">total_group_importance</span><span class="p">;</span>

  <span class="cm">/* The light_to_tree array doubles as a lookup table for
   * both the light tree as well as the distant lights group.*/</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">distant_light</span> <span class="o">=</span> <span class="n">kernel_data_fetch</span><span class="p">(</span><span class="n">light_to_tree</span><span class="p">,</span> <span class="n">prim</span><span class="p">);</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">num_distant_lights</span> <span class="o">=</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distant_lights</span><span class="p">;</span>

  <span class="kt">float</span> <span class="n">emitter_importance</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">total_importance</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_distant_lights</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">importance</span> <span class="o">=</span> <span class="n">light_tree_distant_light_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">distant_light</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">emitter_importance</span> <span class="o">=</span> <span class="n">importance</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">total_importance</span> <span class="o">+=</span> <span class="n">importance</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">pdf</span> <span class="o">*=</span> <span class="n">emitter_importance</span> <span class="o">/</span> <span class="n">total_importance</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">pdf</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>The calculation here is pretty straight-forward. Similar to the calculation in the light tree, we cache the emitter’s importance while we’re computing the total importance.</p> <h2 id="updating-mis-in-cycles">Updating MIS in Cycles</h2> <p>Now that we have the code to recalculate probabilities, we’re almost done. Just one slight issue: we start at some surface to shoot a ray, but once we’ve intersected something else and need the MIS calculations, we’ve lost the normal information of the original surface. To resolve this, we add a struct member called <code class="language-plaintext highlighter-rouge">mis_origin_n</code> to store the normal when we first prepare things for MIS:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\integrator\shade_surface.h</span>
<span class="n">INTEGRATOR_STATE_WRITE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mis_ray_pdf</span><span class="p">)</span> <span class="o">=</span> <span class="n">bsdf_pdf</span><span class="p">;</span>
<span class="n">INTEGRATOR_STATE_WRITE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mis_ray_t</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
<span class="n">INTEGRATOR_STATE_WRITE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mis_origin_n</span><span class="p">)</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">N</span><span class="p">;</span>
<span class="n">INTEGRATOR_STATE_WRITE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">min_ray_pdf</span><span class="p">)</span> <span class="o">=</span> <span class="n">fminf</span><span class="p">(</span>
    <span class="n">bsdf_pdf</span><span class="p">,</span> <span class="n">INTEGRATOR_STATE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">min_ray_pdf</span><span class="p">));</span>
</code></pre></div></div> <p>Here, <code class="language-plaintext highlighter-rouge">sd</code> contains information about the current shading point, so we want to hold onto the normal for later. Now we have all the data we need to recalculate our PDFs. In the last post, I mentioned that I was going to be updating some PDF functions, but then I felt like it was actually cleaner to instead update the functions that were actually performing the MIS. These functions included:</p> <ul> <li><code class="language-plaintext highlighter-rouge">integrate_light()</code> for light sources</li> <li><code class="language-plaintext highlighter-rouge">integrate_surface_emission()</code> for emissive triangles</li> <li><code class="language-plaintext highlighter-rouge">integrate_distant_lights()</code> for sun lights</li> <li><code class="language-plaintext highlighter-rouge">integrator_eval_background_shader()</code> for background lights</li> </ul> <p>The pattern is pretty much the same for each of these functions. While the MIS weighting is performed, we readjust the <code class="language-plaintext highlighter-rouge">LightSample</code>’s PDF to account for the light tree if it’s being used:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\integrator\shade_light.h</span>
<span class="cm">/* MIS weighting. */</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">path_flag</span> <span class="o">&amp;</span> <span class="n">PATH_RAY_MIS_SKIP</span><span class="p">))</span> <span class="p">{</span>
<span class="cm">/* multiple importance sampling, get regular light pdf,
    * and compute weight with respect to BSDF pdf */</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">mis_ray_pdf</span> <span class="o">=</span> <span class="n">INTEGRATOR_STATE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mis_ray_pdf</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">use_light_tree</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">float3</span> <span class="n">N</span> <span class="o">=</span> <span class="n">INTEGRATOR_STATE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mis_origin_n</span><span class="p">);</span>
    <span class="n">ls</span><span class="p">.</span><span class="n">pdf</span> <span class="o">*=</span> <span class="n">light_tree_pdf</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">ray_P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="o">~</span><span class="n">ls</span><span class="p">.</span><span class="n">lamp</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">mis_weight</span> <span class="o">=</span> <span class="n">light_sample_mis_weight_forward</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">mis_ray_pdf</span><span class="p">,</span> <span class="n">ls</span><span class="p">.</span><span class="n">pdf</span><span class="p">);</span>
<span class="n">light_eval</span> <span class="o">*=</span> <span class="n">mis_weight</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Write to render buffer. */</span>
<span class="k">const</span> <span class="n">float3</span> <span class="n">throughput</span> <span class="o">=</span> <span class="n">INTEGRATOR_STATE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">throughput</span><span class="p">);</span>
<span class="n">kernel_accum_emission</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">throughput</span> <span class="o">*</span> <span class="n">light_eval</span><span class="p">,</span> <span class="n">render_buffer</span><span class="p">,</span> <span class="n">ls</span><span class="p">.</span><span class="n">group</span><span class="p">);</span>
</code></pre></div></div> <p>In this case, <code class="language-plaintext highlighter-rouge">ray_P</code> represents the origin of the ray (aka the position of our shading point), but that’s something that’s already being stored in the integrator state.</p> <h2 id="closing-thoughts">Closing Thoughts</h2> <p>Overall, this week was a bit heavier on the debugging side again. I think I made too many modifications at the beginning again, which made it a lot harder to debug some things down the line. I had to jump between commits a few times just to make some sanity checks! Thankfully, it seems to have worked out for now…</p> <p>On the non-MIS side of things, the debugging allowed me to catch some more obvious mistakes which improved the importance heuristics a lot. These things were actually more related to some topics I’ve already posted about, so I’ll try to just edit the existing ones instead of creating new posts. The main contributions were:</p> <ul> <li>Remodifying some of the triangle sampling logic</li> <li>Adjusting the distant light importance heuristic</li> </ul> <p>Sometimes it’s a painful process, but as I mentioned before, it’s extremely rewarding to see things work out! Again, I’m still using some special test cases, but some scenes are already being rendered in less time (with adaptive sampling) compared to the original method. The last thing I haven’t tested yet is environment HDRIs. Hopefully it goes smoothly, but I’m sure I’ll run into something that can at least be improved.</p>]]></content><author><name></name></author><category term="gsoc-2022"/><category term="path-tracing"/><summary type="html"><![CDATA[Fixes to the PDF calculations to adjust for the light tree sampling.]]></summary></entry><entry><title type="html">Adding More Light Types</title><link href="https://jebbly.github.io/blog/2022/more-light-types/" rel="alternate" type="text/html" title="Adding More Light Types"/><published>2022-07-02T00:00:00+00:00</published><updated>2022-07-02T00:00:00+00:00</updated><id>https://jebbly.github.io/blog/2022/more-light-types</id><content type="html" xml:base="https://jebbly.github.io/blog/2022/more-light-types/"><![CDATA[<p>In this post, I’ll be discussing how the different light types in Blender were incorporated into the many lights sampling algorithm. Some of these lights could be immediately plugged in to the existing work, but others needed some redesigning of the logic.</p> <h2 id="different-light-types">Different Light Types</h2> <p>Blender has a variety of light types that all need to be supported by the algorithm. This includes:</p> <ul> <li>Point, Spot, and Area Lights</li> <li>Emissive Triangles</li> <li>Distant and Background Lights</li> </ul> <p>Each of these bullet points have slightly different places in the code, which I’ll elaborate on below.</p> <h3 id="point-spot-and-area-lights">Point, Spot, and Area Lights</h3> <p>Once we have point lights working, it’s really immediate to also incorporate spot and area lights. All we have to do is update our light tree construction to account for their different bounding information (actually, I had to update some of the traversal code as well, but the next section will explain why I don’t discuss it here). The first thing to get out of the way is that the energy calculations for these light types are exactly the same. Next, this is the different bounding cone information for each light type:</p> <table> <thead> <tr> <th style="text-align: center">Light Type</th> <th style="text-align: center">Axis</th> <th style="text-align: center">\(\theta_o\)</th> <th style="text-align: center">\(\theta_e\)</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">Point</td> <td style="text-align: center">Arbitrary</td> <td style="text-align: center">\(\pi\)</td> <td style="text-align: center">\(\pi / 2\)</td> </tr> <tr> <td style="text-align: center">Spot</td> <td style="text-align: center">Spotlight Direction</td> <td style="text-align: center">0</td> <td style="text-align: center">Spotlight Angle</td> </tr> <tr> <td style="text-align: center">Area</td> <td style="text-align: center">Normal Axis</td> <td style="text-align: center">0</td> <td style="text-align: center">\(\pi / 2\)</td> </tr> </tbody> </table> <p>This makes sense because point lights don’t have a defined orientation direction while spot lights and area lights do. Implementing this in the code is also very straightforward using a bunch of conditionals.</p> <p>The bounding box information for these lights is only slightly more interesting, and there are only a few things to note. The point lights and spot lights have an associated <code class="language-plaintext highlighter-rouge">size</code>. What this means is that they can actually emit light from a radius of that size, so our bounding box needs to account for that radius. On the other hand, area lights can either be a disk or a rectangle, and thus have 2 dimensions to them. They have the members <code class="language-plaintext highlighter-rouge">axisu</code> and <code class="language-plaintext highlighter-rouge">axisv</code> which correspond to the orientation of those dimensions, as well as a <code class="language-plaintext highlighter-rouge">sizeu</code> and <code class="language-plaintext highlighter-rouge">sizev</code> which dictate how far along the axis it goes. Knowing this, the code is also relatively straightforward:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\scene\light_tree.cpp</span>
<span class="n">Light</span> <span class="o">*</span><span class="n">lamp</span> <span class="o">=</span> <span class="n">scene</span><span class="o">-&gt;</span><span class="n">lights</span><span class="p">[</span><span class="n">lamp_id</span><span class="p">];</span>
<span class="n">LightType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">get_light_type</span><span class="p">();</span>
<span class="k">const</span> <span class="n">float3</span> <span class="n">center</span> <span class="o">=</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">get_co</span><span class="p">();</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">size</span> <span class="o">=</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">get_size</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">LIGHT_POINT</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="n">LIGHT_SPOT</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* Point and spot lights can emit light from any point within its radius. */</span>
  <span class="k">const</span> <span class="n">float3</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">make_float3</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
  <span class="n">bbox</span><span class="p">.</span><span class="n">grow</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">radius</span><span class="p">);</span>
  <span class="n">bbox</span><span class="p">.</span><span class="n">grow</span><span class="p">(</span><span class="n">center</span> <span class="o">+</span> <span class="n">radius</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">LIGHT_AREA</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* For an area light, sizeu and sizev determine the 2 dimensions of the area light,
  * while axisu and axisv determine the orientation of the 2 dimensions.
  * We want to add all 4 corners to our bounding box. */</span>
  <span class="k">const</span> <span class="n">float3</span> <span class="n">half_extentu</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">get_sizeu</span><span class="p">()</span> <span class="o">*</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">get_axisu</span><span class="p">()</span> <span class="o">*</span> <span class="n">size</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">float3</span> <span class="n">half_extentv</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">get_sizev</span><span class="p">()</span> <span class="o">*</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">get_axisv</span><span class="p">()</span> <span class="o">*</span> <span class="n">size</span><span class="p">;</span>

  <span class="n">bbox</span><span class="p">.</span><span class="n">grow</span><span class="p">(</span><span class="n">center</span> <span class="o">+</span> <span class="n">half_extentu</span> <span class="o">+</span> <span class="n">half_extentv</span><span class="p">);</span>
  <span class="n">bbox</span><span class="p">.</span><span class="n">grow</span><span class="p">(</span><span class="n">center</span> <span class="o">+</span> <span class="n">half_extentu</span> <span class="o">-</span> <span class="n">half_extentv</span><span class="p">);</span>
  <span class="n">bbox</span><span class="p">.</span><span class="n">grow</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">half_extentu</span> <span class="o">+</span> <span class="n">half_extentv</span><span class="p">);</span>
  <span class="n">bbox</span><span class="p">.</span><span class="n">grow</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">half_extentu</span> <span class="o">-</span> <span class="n">half_extentv</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>In other parts of the Cycles code, the area light’s size is also scaled by the <code class="language-plaintext highlighter-rouge">size</code> member. I’ve always seen this factor equal to 1.0 in my own debugging, but I’ve left it here just to be safe.</p> <h3 id="emissive-triangles">Emissive Triangles</h3> <p>Even though I have a separate section for emissive triangles, I’m not really going to talk about the bounding information calculation (most of it was based off the past GSoC work anyways). Instead, this is going to be about how emissive triangles made me realize that some of the traversal logic needed to be reconsidered.</p> <p>Originally, I didn’t think there would be anything too special about triangle lights besides using the <code class="language-plaintext highlighter-rouge">prim_id</code> to distinguish them during light tree construction. However, when I got to traversal, I encountered a slight issue: although I could differentiate between a normal light source and an emissive triangle using the <code class="language-plaintext highlighter-rouge">light_distribution</code> array, I still didn’t have enough information to calculate the importance. It’s still possible to get the triangle’s vertices to manually calculate the bounding box min/max and also take the cross product to find the orientation axis. But then there’s also the issue of finding a proper energy estimate.</p> <p>In any case, doing all of this work during traversal seems like a huge performance issue. Additionally, this information is stuff that we can calculate at construction time and then store for the future. So using the same idea as the <code class="language-plaintext highlighter-rouge">device_vector&lt;KernelLightTreeNode&gt; light_tree_nodes</code>, there’s an array on the device containing the bounding information for each emitter:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\types.h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">KernelLightTreeEmitter</span> <span class="p">{</span>
  <span class="cm">/* Bounding box. */</span>
  <span class="kt">float</span> <span class="n">bounding_box_min</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">float</span> <span class="n">bounding_box_max</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

  <span class="cm">/* Bounding cone. */</span>
  <span class="kt">float</span> <span class="n">bounding_cone_axis</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">float</span> <span class="n">theta_o</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">theta_e</span><span class="p">;</span>

  <span class="cm">/* Energy. */</span>
  <span class="kt">float</span> <span class="n">energy</span><span class="p">;</span>

  <span class="cm">/* prim_id denotes the location in the lights or triangles array. */</span>
  <span class="kt">int</span> <span class="n">prim_id</span><span class="p">;</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">shader_flag</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">object_id</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">mesh_light</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
      <span class="kt">float</span> <span class="n">pad</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">size</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">lamp</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="cm">/* Padding. */</span>
  <span class="kt">int</span> <span class="n">pad1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">KernelLightTreeEmitter</span><span class="p">;</span>
<span class="n">static_assert_align</span><span class="p">(</span><span class="n">KernelLightTreeEmitter</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</code></pre></div></div> <p>The information under <code class="language-plaintext highlighter-rouge">prim_id</code> is the same as the information from the light distribution. However, by keeping it inside of this struct, we can remove our light tree kernel’s dependency on the light distribution. There still is a lot of overlap between this struct and the <code class="language-plaintext highlighter-rouge">KernelLightTreeNode</code> struct, but it works for now. Now after our construction has sorted all of the primitives in order, we can fill out the corresponding bounding information:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\scene\light.cpp</span>
<span class="n">KernelLightTreeEmitter</span> <span class="o">*</span><span class="n">light_tree_emitters</span> <span class="o">=</span> <span class="n">dscene</span><span class="o">-&gt;</span><span class="n">light_tree_emitters</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="n">num_distribution</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">num_distribution</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">LightTreePrimitive</span> <span class="o">&amp;</span><span class="n">prim</span> <span class="o">=</span> <span class="n">light_prims</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
  <span class="n">BoundBox</span> <span class="n">bbox</span> <span class="o">=</span> <span class="n">prim</span><span class="p">.</span><span class="n">calculate_bbox</span><span class="p">(</span><span class="n">scene</span><span class="p">);</span>
  <span class="n">OrientationBounds</span> <span class="n">bcone</span> <span class="o">=</span> <span class="n">prim</span><span class="p">.</span><span class="n">calculate_bcone</span><span class="p">(</span><span class="n">scene</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">energy</span> <span class="o">=</span> <span class="n">prim</span><span class="p">.</span><span class="n">calculate_energy</span><span class="p">(</span><span class="n">scene</span><span class="p">);</span>

  <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">energy</span> <span class="o">=</span> <span class="n">energy</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">bounding_box_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">.</span><span class="n">min</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">bounding_box_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">.</span><span class="n">max</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">bounding_cone_axis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bcone</span><span class="p">.</span><span class="n">axis</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">theta_o</span> <span class="o">=</span> <span class="n">bcone</span><span class="p">.</span><span class="n">theta_o</span><span class="p">;</span>
  <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">theta_e</span> <span class="o">=</span> <span class="n">bcone</span><span class="p">.</span><span class="n">theta_e</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">prim</span><span class="p">.</span><span class="n">prim_id</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">mesh_light</span><span class="p">.</span><span class="n">object_id</span> <span class="o">=</span> <span class="n">prim</span><span class="p">.</span><span class="n">object_id</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">shader_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// query shader flags (same as light distirbution)</span>
    <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">mesh_light</span><span class="p">.</span><span class="n">shader_flag</span> <span class="o">=</span> <span class="n">shader_flag</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">Light</span> <span class="o">*</span><span class="n">lamp</span> <span class="o">=</span> <span class="n">scene</span><span class="o">-&gt;</span><span class="n">lights</span><span class="p">[</span><span class="n">prim</span><span class="p">.</span><span class="n">lamp_id</span><span class="p">];</span>
    <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">lamp</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">lamp</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="n">light_tree_emitters</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">lamp</span><span class="p">.</span><span class="n">pad</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">dscene</span><span class="o">-&gt;</span><span class="n">light_tree_emitters</span><span class="p">.</span><span class="n">copy_to_device</span><span class="p">();</span>
</code></pre></div></div> <p>The advantage of this approach is that all of the decision making is happening at construction time. During traversal, we don’t need any conditionals to handle a different construction for each type of light. We just trust that all the information has been calculated correctly beforehand and then directly plug it into our formula.</p> <p>The last thing to do is to adjust the triangle sampling PDF. If you recall in my last post, I mentioned that the light distribution will pre-calculate some of the PDF. For example, for light sources, it knows that it’ll be sampling uniformly over light samples, so it sets</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\scene\light.cpp</span>
<span class="n">kintegrator</span><span class="o">-&gt;</span><span class="n">pdf_lights</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">num_lights</span><span class="p">;</span>
</code></pre></div></div> <p>On the other hand, the light distribution samples triangles relative to their total area. This is something that varies per-triangle, so the best that can be done is to pre-compute <code class="language-plaintext highlighter-rouge">kintegrator-&gt;pdf_triangles</code> as <code class="language-plaintext highlighter-rouge">1.0f / trianglearea</code>. Then the contributing PDf is calculated during <code class="language-plaintext highlighter-rouge">triangle_light_sample()</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light.h</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">pdf</span> <span class="o">=</span> <span class="n">area</span> <span class="o">*</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">pdf_triangles</span><span class="p">;</span>
</code></pre></div></div> <p>We’ll also be using <code class="language-plaintext highlighter-rouge">triangle_light_sample()</code>, but that’s not going to be the PDF of our sampling method. Instead, we set <code class="language-plaintext highlighter-rouge">kintegrator-&gt;pdf_triangles</code> and then divide <code class="language-plaintext highlighter-rouge">ls-&gt;pdf</code> by the triangle’s area to counteract the multiplication done inside of the function. This essentially converts the pre-computed PDF to <code class="language-plaintext highlighter-rouge">1.0f</code>, so now we’re free to control the PDF appropriately.</p> <h3 id="distant-and-background-lights">Distant and Background Lights</h3> <p>The reason why distant lights and background lights need to be handled separately is because the light tree is inherently location-based. Since these lights can be considered infinitely far away, we can’t really construct a bounding box or anything to make them part of the light tree. The original method we wanted to implement was to first pick a light from a light tree and another light from the distant/background lights, and then choose one of the two after weighing their importances. The idea would be that having 2 specific lights would be more specific.</p> <p>However, halfway through implementing this, I discovered that this would actually be pretty complicated. This is because we not only need to calculate the probability of selecting the light in order to scale our PDF accordingly. Now suppose we select one object from \(A = \{A_1, A_2\}\) and one object from \(B = \{B_1, B_2\}\). Then we put our two selected objects into a new group \(C\) and select one out of the two. For the sake of shorter notation, let \(O_{i_N}\) denote the probability of selecting object \(O_i\) from group \(N\). Now the probability of ending up with \(A_1\) as our final selection would be:</p> \[\mathbb{P}(A_{1_C}) = \mathbb{P}(A_{1_C} | A_{1_A} \cap B_{1_B}) \cdot \mathbb{P}(A_{1_A} \cap B_{1_B}) + \mathbb{P}(A_{1_C} | A_{1_A} \cap B_{2_B}) \cdot \mathbb{P}(A_{1_A} \cap B_{2_B})\] <p>Technically there are a few more terms (cases where \(A_2\) is selected from group \(A\)) but we can ignore them because they’re all equal to \(0\). The general idea is that to find the actual probability, we’d have to partition the probabilities into cases. So in this case, the true probability of selecting \(A_1\) is the probability of selecting it when \(C = \{A_1, B_1\}\) plus the probability of selecting it when \(C = \{A_1, B_2\}\). In code, we’d be able to naturally find the value of a single one of these terms, but we’d have to do a lot of extra computation to find the others.</p> <p>The next best thing we can do is first decide whether we want to sample from the light tree or to sample from the distant lights. For now, the easiest way to do this is by examining their relative energies. The advantage to this approach is that we can pre-compute both of these during construction time, but in the future, we may want to introduce an appropriate importance heuristic to decide between the two. Here, <code class="language-plaintext highlighter-rouge">pdf_light_tree</code> is calculated as the relative energy of the light tree compared to the total energy involved:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light_tree.h</span>
<span class="kt">float</span> <span class="n">tree_u</span> <span class="o">=</span> <span class="n">path_state_rng_1D</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">rng_state</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">tree_u</span> <span class="o">&lt;</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">pdf_light_tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pdf_factor</span> <span class="o">*=</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">pdf_light_tree</span><span class="p">;</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">light_tree_sample</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">(</span>
      <span class="n">kg</span><span class="p">,</span> <span class="n">rng_state</span><span class="p">,</span> <span class="n">randu</span><span class="p">,</span> <span class="n">randv</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">bounce</span><span class="p">,</span> <span class="n">path_flag</span><span class="p">,</span> <span class="n">ls</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdf_factor</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="n">pdf_factor</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">pdf_light_tree</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">light_tree_sample_distant_lights</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">(</span>
      <span class="n">kg</span><span class="p">,</span> <span class="n">rng_state</span><span class="p">,</span> <span class="n">randu</span><span class="p">,</span> <span class="n">randv</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">bounce</span><span class="p">,</span> <span class="n">path_flag</span><span class="p">,</span> <span class="n">ls</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdf_factor</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>The downside to this approach is that we’ll have to perform a linear scan if we want to sample from the distant lights group. Realistically though, or at least from my perpective, most scenes shouldn’t have that many distant lights. Furthermore, we can also compute importance heuristics if we choose to sample from the distant light group, so we can make more informed decisions about which light to sample.</p> <p>For now, <code class="language-plaintext highlighter-rouge">light_tree_distant_light_importance()</code> only returns the energy of the given distant light:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light_tree.h</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">num_distant_lights</span> <span class="o">=</span> <span class="n">kernel_data</span><span class="p">.</span><span class="n">integrator</span><span class="p">.</span><span class="n">num_distant_lights</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">total_importance</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_distant_lights</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">total_importance</span> <span class="o">+=</span> <span class="n">light_tree_distant_light_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">inv_total_importance</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">total_importance</span><span class="p">;</span>

<span class="kt">float</span> <span class="n">light_cdf</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">distant_u</span> <span class="o">=</span> <span class="n">path_state_rng_1D</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">rng_state</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_distant_lights</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">float</span> <span class="n">light_pdf</span> <span class="o">=</span> <span class="n">light_tree_distant_light_importance</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span>
                          <span class="n">inv_total_importance</span><span class="p">;</span>
  <span class="n">light_cdf</span> <span class="o">+=</span> <span class="n">light_pdf</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">distant_u</span> <span class="o">&lt;</span> <span class="n">light_cdf</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">pdf_factor</span> <span class="o">*=</span> <span class="n">light_pdf</span><span class="p">;</span>
    <span class="n">ccl_global</span> <span class="k">const</span> <span class="n">KernelLightTreeDistantEmitter</span> <span class="o">*</span><span class="n">kdistant</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_data_fetch</span><span class="p">(</span>
        <span class="n">light_tree_distant_group</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">lamp</span> <span class="o">=</span> <span class="o">-</span><span class="n">kdistant</span><span class="o">-&gt;</span><span class="n">prim_id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">light_select_reached_max_bounces</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">lamp</span><span class="p">,</span> <span class="n">bounce</span><span class="p">)))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">light_sample</span><span class="o">&lt;</span><span class="n">in_volume_segment</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kg</span><span class="p">,</span> <span class="n">lamp</span><span class="p">,</span> <span class="n">randu</span><span class="p">,</span> <span class="n">randv</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">path_flag</span><span class="p">,</span> <span class="n">ls</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is bound to change as we come up with better heuristics in the future.</p> <h2 id="closing-thoughts">Closing Thoughts</h2> <p>Thanks to the heavy debugging from the work with point lights, most of the math was pretty much working from the get-go. However, there’s still a lot of optimizations to the heuristics that can (and will) be made. My main concern at the moment is that these heuristics don’t take visibility into consideration, which can really hurt the sampling in extreme cases. For example in one case, we could be placing high importance on one group of lights and dedicating a lot of samples towards them, without realizing that they’re actually all occluded! We’ll have to have another discussion for this in the future, but one solution that comes to mind is to also randomly select between using the light tree sampling and using the default light distribution sampling.</p> <p>Secondly, I also realized that there are 3 additional functions to update, which are used when Cycles performs indirect light samples (I’ll be making a separate post about this). These functions are basically used when Cycles is sampling based off of the BSDF and the sample intersects a light source, so we need to calculate what the direct lighting’s PDF would be in order to weight the multiple importance sampling. The functions are:</p> <ul> <li><code class="language-plaintext highlighter-rouge">background_light_pdf()</code></li> <li><code class="language-plaintext highlighter-rouge">triangle_light_pdf()</code></li> <li><code class="language-plaintext highlighter-rouge">light_sample_from_intersection()</code></li> </ul> <p>These functions are pretty self-explanatory, but it’ll be a little tricky to incorporate the light tree into them. More on that in the next post!</p>]]></content><author><name></name></author><category term="gsoc-2022"/><category term="path-tracing"/><summary type="html"><![CDATA[How different light types in Blender are used in the many lights sampling algorithm.]]></summary></entry><entry><title type="html">Supporting Point Lights</title><link href="https://jebbly.github.io/blog/2022/blender-point-lights/" rel="alternate" type="text/html" title="Supporting Point Lights"/><published>2022-06-18T00:00:00+00:00</published><updated>2022-06-18T00:00:00+00:00</updated><id>https://jebbly.github.io/blog/2022/blender-point-lights</id><content type="html" xml:base="https://jebbly.github.io/blog/2022/blender-point-lights/"><![CDATA[<p>This is finally going to be a more technical post. As the title suggests, I’m going to cover how the many lights algorithm supports point lights in Blender. I expect this to be a slightly lengthier post because I want record some insights I’ve discovered about Cycles, some details that Brecht and Lukas have explained to me, and some more details about the algorithm itself. Before reading this, I would highly recommend reading either my previous posts or <a href="http://www.aconty.com/pdf/many-lights-hpg2018.pdf">the original paper</a>.</p> <p>Also, just as an update, it seems like Cycles has recently updated their device code and no longer refers to the device arrays as “textures” anymore. You’ll see what I mean if you read the section about transferring to device-side - just know that “data arrays” are now the equivalent of what I meant by “textures.”</p> <h2 id="implementation">Implementation</h2> <p>Before I get into the details of the implementation itself, I first want to go over some of what I’ve learned about Cycles. From what I understand, the device-side kernel has two main ways of keeping track of data. Both are stored in a struct called <code class="language-plaintext highlighter-rouge">KernelGlobals</code>. In this struct, it contains a member called <code class="language-plaintext highlighter-rouge">__data</code>, which in turn contains members such as the <code class="language-plaintext highlighter-rouge">integrator</code> that contains certain render settings and fixed constants. This takes up a fixed amount of memory and I imagine that it should be faster to access on the device. The struct also contains other data in the form of flat arrays. The amount of data that goes in here is dynamic, i.e. the lights in the scene. This is where we’ll also be adding new data such as the nodes of the light tree to traverse (more on that later).</p> <p>When Cycles starts rendering, the logic goes through a megakernel that determines which functions to call next. For example, the first function to call may be <code class="language-plaintext highlighter-rouge">integrator_intersect_closest()</code> to find an intersection. That function can write things to some state for other functions to read later, and it can also schedule the next kernel task. For example, after finding an intersection with a surface, we may want to queue <code class="language-plaintext highlighter-rouge">integrator_surface_direct_light()</code> which will sample a light, and then in turn call <code class="language-plaintext highlighter-rouge">integrator_intersect_shadow()</code> to check the visibilty of that light.</p> <p>Knowing this, there are essentially 3 main tasks:</p> <ol> <li>Using the scene information to construct the light tree on the host side,</li> <li>Transferring the light tree to access on the device side,</li> <li>Using the light tree to determine light sampling in the kernel.</li> </ol> <p>Next, I’ll elaborate on how each task was implemented.</p> <h3 id="host-side-construction">Host-side Construction</h3> <p>As I mentioned in an earlier post, the host-side construction of the light tree isn’t really anything notable. It follows PBRT very strictly, but we replace the surface area heuristic (SAH) with the surface area orientation heuristic. This is done by associating each light primitive and node with an additional bounding cone that keeps track of orientation and general emission direction. Here, we define a custom struct called <code class="language-plaintext highlighter-rouge">OrientationBounds</code> to keep track of this information:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern/cycles/scene/light_tree.h</span>
<span class="k">struct</span> <span class="nc">OrientationBounds</span> <span class="p">{</span>
  <span class="n">float3</span> <span class="n">axis</span><span class="p">;</span> <span class="cm">/* normal axis of the light */</span>
  <span class="kt">float</span> <span class="n">theta_o</span><span class="p">;</span> <span class="cm">/* angle bounding the normals */</span>
  <span class="kt">float</span> <span class="n">theta_e</span><span class="p">;</span> <span class="cm">/* angle bounding the light emissions */</span>
<span class="p">}</span>
</code></pre></div></div> <p>The reason we have both \(\theta_o\) and \(\theta_e\) is for certain light sources, like a point light. Since there’s really no “orientation axis” for a point light, we can technically consider any direction to be the orientation and then bound the axis to be within \(\theta_o = \pi\) radians of that direction. Then the \(\theta_e\) describes the angle of light that will be directed in the orientation axis. Again for a point light, this covers an angle of \(\pi/2\) around the orientation axis, and any angle past that will be facing behind the axis.</p> <p>When we merge two bounding cones, we find the centroid of the orientation axis, and then we compute new values for \(\theta_o\) and \(\theta_e\) that will bound that of the original two. This seems to be a generelly effective and safe approximation of the net bounding cone, but if I have time, I may consider somehow incorporating position data into this merge.</p> <h3 id="transferring-to-device-side">Transferring to Device-side</h3> <p>In my second post, I also discussed the sort of information that we need to access for traversal on the device side. I’ll explain why we need certain information in the next section, so this section is just focused on how we transform the information from the host-side into a flat array on the device side. We add have an array of this struct to be stored on the device:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern/cycles/kernel/types.h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">KernelLightTreeNode</span> <span class="p">{</span>
  <span class="cm">/* Bounding box. */</span>
  <span class="kt">float</span> <span class="n">bounding_box_min</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">float</span> <span class="n">bounding_box_max</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

  <span class="cm">/* Bounding cone. */</span>
  <span class="kt">float</span> <span class="n">bounding_cone_axis</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">float</span> <span class="n">theta_o</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">theta_e</span><span class="p">;</span>

  <span class="cm">/* Energy. */</span>
  <span class="kt">float</span> <span class="n">energy</span><span class="p">;</span>

  <span class="cm">/* If this is 0 or less, we're at a leaf node
  /* and the negative value indexes into the first child of the light array.
  /* Otherwise, it's an index to the node's second child. */</span>
  <span class="kt">int</span> <span class="n">child_index</span><span class="p">;</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">num_prims</span><span class="p">;</span> <span class="cm">/* leaf nodes need to know the number of primitives stored. */</span>
    <span class="kt">float</span> <span class="n">energy_variance</span><span class="p">;</span> <span class="cm">/* interior nodes use the energy variance for the splitting heuristic. */</span>
  <span class="p">};</span>

  <span class="cm">/* Padding. */</span>
  <span class="kt">int</span> <span class="n">pad1</span><span class="p">,</span> <span class="n">pad2</span><span class="p">;</span>
<span class="p">}</span> <span class="n">KernelLightTreeNode</span><span class="p">;</span>
<span class="n">static_assert_align</span><span class="p">(</span><span class="n">KernelLightTreeNode</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</code></pre></div></div> <p>In my previous post, I mentioned that we would use two separate structs to store interior and leaf nodes. However, as explained in the comments, we can use the <code class="language-plaintext highlighter-rouge">child_index</code> to determine whether or not a node is an interior or leaf node. Then the union is used to store the non-overlapping information. Other than that, we need the two extra <code class="language-plaintext highlighter-rouge">pad1, pad2</code> ints at the bottom to pad our struct so that it aligns to 16 bytes.</p> <p>Now we need to add an array of this struct to the <code class="language-plaintext highlighter-rouge">DeviceScene</code>. This is what we’ll actually be able to access through the kernels:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\scene\scene.h</span>
<span class="k">class</span> <span class="nc">DeviceScene</span> <span class="p">{</span>
<span class="nl">public:</span>
<span class="p">...</span>
<span class="cm">/* light tree */</span>
<span class="n">device_vector</span><span class="o">&lt;</span><span class="n">KernelLightTreeNode</span><span class="o">&gt;</span> <span class="n">light_tree_nodes</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">}</span>

<span class="c1">// intern\cycles\scene\scene.cpp</span>
<span class="n">DeviceScene</span><span class="o">::</span><span class="n">DeviceScene</span><span class="p">(</span><span class="n">Device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
    <span class="o">:</span> <span class="p">...,</span>
      <span class="n">light_tree_nodes</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="s">"__light_tree_nodes"</span><span class="p">,</span> <span class="n">MEM_GLOBAL</span><span class="p">),</span>
      <span class="p">...,</span>
<span class="p">{...}</span>
</code></pre></div></div> <p>The reason why we pass those parameters to initialize <code class="language-plaintext highlighter-rouge">light_tree_nodes</code> is because the <code class="language-plaintext highlighter-rouge">device_vector</code> uses this information when copying to the device. From my understanding, it’s kind of like an intermediary where we can fill in the <code class="language-plaintext highlighter-rouge">device_vector</code> from the host side, and then tell it to transfer that information to the device. In Cycles, arrays of data are stored as textures on the device, and the <code class="language-plaintext highlighter-rouge">device_vector</code> will look for a texture with the given name to populate. Ihis case, we passed in <code class="language-plaintext highlighter-rouge">"__light_tree_nodes"</code> as the name, so we need to make sure there’s an appropriate texture that corresponds to that name:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\textures.h</span>
<span class="p">...</span>
<span class="cm">/* light tree */</span>
<span class="n">KERNEL_TEX</span><span class="p">(</span><span class="n">KernelLightTreeNode</span><span class="p">,</span> <span class="n">__light_tree_nodes</span><span class="p">)</span>
<span class="p">...</span>
</code></pre></div></div> <p>The last thing we need to do is populate the <code class="language-plaintext highlighter-rouge">device_vector</code> before we tell it to transfer its data to the device. Since PBRT’s BVH construction already flattens the tree, all we need to do is iterate through the packed array and create the device-side struct accordingly. Sounds easy, but before we even construct the BVH, we first need to obtain an array with all the light primitives to be included in our BVH. Since we’re only dealing with point lights for now, this isn’t very interesting (and this post is getting quite lengthy), so I’ll omit it for a later discussion when more types are supported. For now, just trust that we’ve successfully transferred our linearized BVH onto the device through the texture <code class="language-plaintext highlighter-rouge">__light_tree_nodes</code>.</p> <h3 id="device-side-traversal">Device-side Traversal</h3> <p>Now that our light tree is on the device, we can use it to take more informed samples. When we begin at the very top parent of the light tree, we need some way to decide which child we should traverse to, i.e. what the relative importance of each child is. Recalling the rendering equation, there’s 2 main terms to consider:</p> <ol> <li>The irradiance term, \(L_i(p, \omega_i)\);</li> <li>The BSDF term, \(f(p, \omega_i, \omega_o)\).</li> </ol> <p>The importance of a node cluster should thus be an approximation of how much it relatively contributes to these terms. To do this, we want to loosely bound the range of possible values. This is the diagram that the original paper uses:</p> <figure> <picture> <img src="/assets/img/blog/gsoc/diagram.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>This is how the symbols are defined:</p> <ul> <li>\(\theta\) is the angle formed between the cluster’s bounding cone axis and the vector pointing from the centroid to the shading point,</li> <li>\(\theta_u\) is the max angle required to encompass the entire bounding box (around an vector pointing from the shading point to the centroid),</li> <li>\(\theta_i\) is the angle between the shading point normal and the centroid.</li> </ul> <p>The paper then gives the importance measure as follows:</p> \[I = \frac{f \lvert \cos(\theta_i') \rvert}{d^2} \times \begin{cases} \cos(\theta') &amp; \theta' &lt; \theta_e, \\ 0 &amp; \text{otherwise}. \end{cases}\] <p>where \(\theta_i' = max\{\theta_i - \theta_u, 0\}\) and \(\theta' = max\{\theta - \theta_o - \theta_u, 0\}\). These are a lot of new terms, but hopefully you can see some loose similarities between this importance measure formula and the integrand in the rendering equation. This is my interpretation of \(\theta_i'\) and \(\theta'\):</p> <ul> <li>\(\theta_i'\) is the minimum angle that could possibly be formed between the shading point normal and a vector pointing from the shading point to a light in the cluster,</li> <li>\(\theta'\) is the minimum angle between the emitter normal and a vector pointing from a light in the cluster to the shading point.</li> </ul> <p>These heuristics are all very loose bounds, but it’s still a decent approximation to determine the weight of sampling each cluster.</p> <p>Writing all the code here would be pretty redundant because as of right now, it’s a pretty immediate mapping from math to code. If you want to look through it, it can be found at <code class="language-plaintext highlighter-rouge">intern\cycles\kernel\light_tree.h</code>. Most of the angles are either already given, or can be calculated by taking \(\cos^{-1}\) of the dot product between the two normalized vectors in question. The only somewhat notable calculation is \(\theta_u\) because there’s no easy way to know what minimum angle will encompass the entire bounding box. As such, we must iterate through each point of the bounding box to find the max angle formed (which will contain all the others).</p> <p>Once we have the relative importance of each child, we assign the probability of traversing to the first and second child (this is also referred to as left and right in the code):</p> \[\mathbb{P}_1 = \frac{I_1}{I_1 + I_2}, \quad \mathbb{P}_2 = \frac{I_2}{I_1 + I_2}.\] <p>Thus, in order to reach a given light, we have to traverse through its ancestors with a given probability each time. At each step in the traversal, we need to make sure the PDF of selecting our light is correct, so we use a <code class="language-plaintext highlighter-rouge">pdf_factor</code> to scale our PDF based on which direction we chose. For example, if we traversed in the order \(L_1, R_2, L_3\), then we also scale our <code class="language-plaintext highlighter-rouge">pdf_factor</code> by \(P_{L_1} \cdot P_{R_2} \cdot P_{L_3}\).</p> <p>Finally, the last step is less related to the paper and more so to Blender’s code. Right now, Blender samples lights and emissive triangles by generating a distribution where each primitive’s <code class="language-plaintext highlighter-rouge">totarea</code> represents its relative weight of being selected. The distribution is “pre-baked” in the sense that it creates a 50-50 probability of selecting either a triangle or a light. Then the probability of selecting a triangle (given that a triangle was selected) is now proportional to its area, and there’s an even probability of selecting any light. Therefore, we have the following code:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\scene\light.cpp</span>
<span class="k">if</span> <span class="p">(</span><span class="n">trianglearea</span> <span class="o">&gt;</span> <span class="mf">0.0f</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">kintegrator</span><span class="o">-&gt;</span><span class="n">pdf_triangles</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">trianglearea</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">num_lights</span><span class="p">)</span>
    <span class="n">kintegrator</span><span class="o">-&gt;</span><span class="n">pdf_triangles</span> <span class="o">*=</span> <span class="mf">0.5f</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">num_lights</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">kintegrator</span><span class="o">-&gt;</span><span class="n">pdf_lights</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">num_lights</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">trianglearea</span> <span class="o">&gt;</span> <span class="mf">0.0f</span><span class="p">)</span>
    <span class="n">kintegrator</span><span class="o">-&gt;</span><span class="n">pdf_lights</span> <span class="o">*=</span> <span class="mf">0.5f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Then the function <code class="language-plaintext highlighter-rouge">light_sample()</code> in the device kernel uses this PDF factor to scale the light sample’s PDF after the rest of the computation. In our case, we still want to use the <code class="language-plaintext highlighter-rouge">light_sample()</code> function, but this baked distribution is no longer being used in our sampling logic. The PDF is dynamic depending on the importance and we’re scaling it in our own sampling function, so we can’t use any pre-baked data. Instead, we just override the factors so that <code class="language-plaintext highlighter-rouge">light_sample()</code> doesn’t additionally scale our PDF incorrectly:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\scene\light.cpp</span>
<span class="k">if</span> <span class="p">(</span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">integrator</span><span class="o">-&gt;</span><span class="n">get_use_light_tree</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">kintegrator</span><span class="o">-&gt;</span><span class="n">pdf_triangles</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
  <span class="n">kintegrator</span><span class="o">-&gt;</span><span class="n">pdf_lights</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="c1">// code from above</span>
<span class="p">}</span>
</code></pre></div></div> <p>If you’ve read the original paper, “Importance Sampling of Many Lights With Adaptive Tree Splitting” by Alejandro Conty Estevez and Christopher Kulla, or my previous post, you may also recall that there’s also something called the splitting threshold. This is when variance of the child nodes is too high, so we choose to sample from both the left and right child instead. However, this implementation isn’t very convenient in the context of how Cycles functions. Since we have to queue kernel tasks and <code class="language-plaintext highlighter-rouge">integrate_surface_direct_light()</code> expects to handle a single light at a time, we’d have to do some weird workarounds to implement the splitting threshold (which samples multiple lights at a time). For now, we’re putting this to the side, but we’ll re-examine it later when the implementation is more stable.</p> <h3 id="debugging-testing-and-benchmarking">Debugging, Testing, and Benchmarking</h3> <p>To debug and test this scene, I created a bunch of scenes that just had a bunch of point lights and no background light. To start, the goal was to get a single point light and cube rendering properly. LazyDodo pointed me towards a useful tool called <code class="language-plaintext highlighter-rouge">idiff</code> which can be used to compare 2 renders, which I would use to verify the accuracy of my implementation when compared to the default Cycles render. It also lets you output a difference image and scale the results (to make it easier to see), which was very useful. Lukas also recommended another tool, <a href="https://github.com/Tom94/tev">tev</a>, to compare images, but I haven’t gotten the chance to try it out yet. Anyways, this is an example of why <code class="language-plaintext highlighter-rouge">idiff</code> is important; here are two of the first renders I did. With one point light, no background light, and a single cube, the left is the Cycles default implementation and the right is my new implementation:</p> <img-comparison-slider> <figure slot="first"> <picture> <img src="/assets/img/blog/gsoc/correct-render.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure slot="second"> <picture> <img src="/assets/img/blog/gsoc/test-render.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </img-comparison-slider> <p>Looks pretty similar, right? Maybe to the naked eye, but <code class="language-plaintext highlighter-rouge">idiff</code> shows the following when I scale the absolute difference by 100:</p> <figure> <picture> <img src="/assets/img/blog/gsoc/diff.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>In reality, the right corner of my implementation is too dark while the other corners are too bright. There were actually a few things wrong with my first implementation. I accidentally swapped the normal and position arguments (this took an embarrasingly long time to figure out), and I didn’t account for the pre-baked light PDFs.</p> <p>Other errors included:</p> <ul> <li>Forgetting to update the node’s energy when transferring it to the device</li> <li>Not initializing the bounding box and bounding cones properly when doing SAOH</li> <li>Forgetting to scale the random number used</li> <li>Swapping the values for \(\theta_i'\) and \(\theta'\) Last but certainly not least, this was the error that took me at least 7 hours to debug:</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intern\cycles\kernel\light\light_tree.h</span>
<span class="k">if</span> <span class="p">(</span><span class="n">tree_u</span> <span class="o">&lt;</span> <span class="n">left_probability</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">knode</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
  <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">tree_u</span> <span class="o">=</span> <span class="n">tree_u</span> <span class="o">*</span> <span class="p">(</span><span class="n">left_importance</span> <span class="o">+</span> <span class="n">right_importance</span><span class="p">)</span> <span class="o">/</span> <span class="n">left_importance</span><span class="p">;</span>
  <span class="o">*</span><span class="n">pdf_factor</span> <span class="o">*=</span> <span class="n">left_probability</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="n">knode</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
  <span class="n">index</span> <span class="o">=</span> <span class="n">knode</span><span class="o">-&gt;</span><span class="n">child_index</span><span class="p">;</span>
  <span class="n">tree_u</span> <span class="o">=</span> <span class="p">(</span><span class="n">tree_u</span> <span class="o">*</span> <span class="p">(</span><span class="n">left_importance</span> <span class="o">+</span> <span class="n">right_importance</span><span class="p">)</span> <span class="o">-</span> <span class="n">left_importance</span><span class="p">)</span> <span class="o">/</span>
            <span class="n">right_importance</span><span class="p">;</span>
  <span class="o">*</span><span class="n">pdf_factor</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">left_probability</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>The error is in the else statement, where <code class="language-plaintext highlighter-rouge">knode = right</code> is called before <code class="language-plaintext highlighter-rouge">index = knode-&gt;child_index</code>. As a result, when we traverse to the node where <code class="language-plaintext highlighter-rouge">child_index</code> is set to the last index in the array, we’re now in an interior node but <code class="language-plaintext highlighter-rouge">index</code> is the last index possible. Then since <code class="language-plaintext highlighter-rouge">knode</code> is still at an interior node, we try to access the left child which is <code class="language-plaintext highlighter-rouge">index + 1</code> and thus out of bounds.</p> <p>I guess after a few hours of debugging already, I didn’t have it in me to catch this bug by inspection - I honestly wasn’t expecting this error at all. Since the conditional is probabilistic, I never encountered it when I was stepping through the code line-by-line. I was also running the render tests through a release-mode build where there were no assertions. I finally hit the assertion fail when I accidentally continued execution in my line-by-line debugging in a debug-mode build.</p> <p>Now the implementation finally has some degree of accuracy when it comes to point lights (at least in special cases). In scenes with lots of point lights, there seems to be some more significant differences in the edges of the cubes. When I increase the sample size, the error there does still decrease, but at a slower rate than the rest of the render. This might be something I’ll look into again later, but I suspect that it’s mostly a precision thing, or something related to the normals near the edges of the cube.</p> <p>Overall, debugging took me way longer than I’d like to admit, but in a sense, I guess it’s a necessary evil. I definitely learned a lot through it, and I hope that addressing these errors early on will make it easier when debugging further features.</p> <h2 id="closing-thoughts">Closing Thoughts</h2> <p>This was my first time really diving into Blender’s source code, so it was really rewarding when some of the tests started passing. That said, it’s still a little too early to start celebrating because these are just special test cases. There’s a lot more testing that needs to be done, and then after that, it’ll be time for optimizations too. As I mentioned in the devtalk, the rough timeline is as follows:</p> <ol> <li>Spot and area lights</li> <li>Emissive triangles</li> <li>Background and distant lights</li> <li>Volumes</li> <li>GPU Implementation</li> </ol> <p>As for the immediate next steps it should be pretty easy to support spot lights and area lights. Since they’re just different lights, it should just be a matter of handling their orientation bounds appropriately. After that, emissive triangles are next on the list - this should also be relatively straight-forward to implement as long as the bounds are constructed properly.</p> <p>As usual, please let me know if there are any errors in this post - I would love to better my understanding of things! If you have any questions or concerns, feel free to ask on <a href="https://devtalk.blender.org/t/gsoc-2022-many-lights-sampling-in-cycles-x-feedback-thread/24773">the devtalk feedback thread</a>. If you also have any scenes with a lot of lights, please do share them! I’ll try to test them as soon as it’s ready for testing.</p>]]></content><author><name></name></author><category term="gsoc-2022"/><category term="path-tracing"/><summary type="html"><![CDATA[A more detailed technical explanation of supporting the many lights algorithm for point lights in Blender.]]></summary></entry><entry><title type="html">Motivating Many Lights Sampling with a Light Tree</title><link href="https://jebbly.github.io/blog/2022/motivating-light-trees/" rel="alternate" type="text/html" title="Motivating Many Lights Sampling with a Light Tree"/><published>2022-06-08T00:00:00+00:00</published><updated>2022-06-08T00:00:00+00:00</updated><id>https://jebbly.github.io/blog/2022/motivating-light-trees</id><content type="html" xml:base="https://jebbly.github.io/blog/2022/motivating-light-trees/"><![CDATA[<p>To start off, I’ll try to describe the motivation for the <a href="https://dl.acm.org/doi/10.1145/3233305">many lights sampling algorithm</a>. In general for Monte Carlo estimation, we want to find ways to obtain the same result with fewer samples and/or obtain more precise results with the same number of samples.</p> <h2 id="importance-sampling">Importance Sampling</h2> <p>One way of doing this is through importance sampling, which is when we try to use sampling PDFs that scale according to the function itself. PBRT does a pretty good job at explaining the intuition behind this technique if you don’t believe me.</p> <p>In the context of light sampling, we’re estimating the integral in the rendering equation:</p> \[L_o(p, \omega_o) = L_e(p, \omega_o) + \int_\Omega f(x, \omega_i, \omega_o) L_i(p, \omega_i) \,d \omega_i\] <p>If we only consider direct lighting for now, i.e. \(L_i(P, \omega_i)\) is from a light source, then importance sampling can be pretty important. Let’s say we’re at an intersection point and we want to find the contribution of all the direct lights. Mathematically speaking, we could just uniformly sample the hemisphere of solid angles and check if there’s a light in that direction. The issue with this approach is that most of the samples are probably going to hit nothing, and even worse, there’s technically a 0% chance of sampling a light with no area (e.g. a point light).</p> <p>Alternatively, one basic approach is to instead sample from the light sources first. This way, if we exclude visibility for now, we can guarantee that our samples are going to be non-zero. This also means we can include the contributions from lights with no area.</p> <h2 id="the-many-lights-sampling-algorithm">The Many Lights Sampling Algorithm</h2> <p>So sampling using light source information is already a step in the right direction, but there’s still room for improvement. For example, shouldn’t we place less emphasis on lights that are either really weak, far away, or facing the other direction? That’s where the many lights sampling algorithm comes into play.</p> <p>The many lights sampling algorithm first constructs a sort of BVH that contains information about the light sources. Starting from the top-level node, it uses some heuristics to collect neighboring lights into two groups, and provides a general idea of the groups’ total energy and orientation. The paper describes a measure to determine the cost of grouping certain lights, so we try to pick the split that minimizes this cost before converting the two groups into child nodes.</p> <p>Once the tree is constructed, we can traverse it when we’re sampling light sources. At each level of the light BVH, we use our heuristics to determine which child we want to examine next. These heuristics will guide us in the general direction towards lights that are going to contribute more towards our final result. As a result, we can introduce a substantially larger number of lights into the scene, which would have previously produced poor results with the basic importance sampling technique.</p> <p>One last thing that the algorithm does is to force splitting during traversal. This is because sometimes, especially in the upper levels of the BVH, a general idea of the total energy and orientation isn’t enough information to decide which child is traverse towards. As a result, some splitting threshold is used so that if the normalized variance of the node is greater than the threshold, we just traverse both children just to be safe.</p> <h2 id="implementation-plan">Implementation Plan</h2> <p>As discussed with Brecht and Lukas, the goal of this project is to progressively add support for more things. In other words, I’ll be starting with just point lights first, and once those are working, I’ll move on to other types. The first step is to actually construct the light BVH on the host, using information about the lights in the scene. Although this did take a while to implement, there’s nothing too interesting. It’s almost all contained in <code class="language-plaintext highlighter-rouge">cycles/scene/light_tree.h</code> and <code class="language-plaintext highlighter-rouge">cycles/scene/light_tree.cpp</code>, where there’s a few extra structs to help out with construction. Otherwise, the overall logic follows the construction of a BVH in PBRT, but the SAH is replaced with the surface area orientation heuristic (SAOH) described in the paper.</p> <p>Once the construction is completed on the host side, there has to be a way to transfer this information to the device for traversal. The one caveat is that the device must take in a linear array of data, so we have to flatten the light BVH nodes. To traverse the interior nodes as a flat array, we need the following information:</p> <ul> <li>Index of the second child</li> <li>Bounding box of the light cluster</li> <li>Bounding cone of the cluster as described in the paper (orientation axis, \(\theta_o\), \(\theta_e\))</li> <li>Total energy and energy variance of the cluster</li> </ul> <p>Note that here, we can construct the array such that the first child is always adjacent to the parent node. As a result, we only need to store the index of the second child. We also keep the leaf nodes as a separate flat array because they store slightly different information. Once we’re at the leaf nodes, we need to know the following:</p> <ul> <li>Number of lights in the leaf</li> <li>Index of the first light in the light array</li> <li>Bounding box of the cluster</li> <li>Bounding cone of the cluster</li> <li>Total energy of the cluster</li> </ul> <p>We can use the index of the second child to go from the interior node array to the leaf node array. if it’s positive, we can assume the children are still interior nodes. Otherwise, if it’s negative, then we can take the negative and index into the leaf onde array. Although there is some overlap between the interior and leaf nodes, we should be able to save some memory by avoiding storage of unused information. Once we’re able to figure out how to traverse on the device, the last step should just be to figure out how to adjust the light PDF so that our estimators remain unbiased.</p> <h2 id="closing-thoughts">Closing Thoughts</h2> <p>Even though it seems relatively short now, this post took a really long time to write. At first, I wanted to go into more detail about multiple importance sampling and then prove some of PBRT’s methods for sampling direct lights. However, after two hours, I realized that I was still regurgitating a lot of information that can already be found on PBRT or Veach’s thesis. As a result, I decided to re-pivot so I could talk about a subject that’s hopefully a little more specific and focused.</p> <p>I also wasn’t really sure how long the post should be, so I tried to describe more of the intuition behind the algorithm and just a high-level overview of the implementation plan. There are some technical details about the implementation that I was hoping to cover, so I’ll try to make a dedicated post about the Blender side of things next time. Otherwise, if anyone has taken the time to read this far, please do let me know any errors I made, how I can improve, or what you’d like to see next!</p>]]></content><author><name></name></author><category term="gsoc-2022"/><category term="path-tracing"/><summary type="html"><![CDATA[An introduction to the many lights sampling algorithm and how I plan to implement it in Blender.]]></summary></entry><entry><title type="html">Introduction to GSoC with Blender</title><link href="https://jebbly.github.io/blog/2022/gsoc-introduction/" rel="alternate" type="text/html" title="Introduction to GSoC with Blender"/><published>2022-06-05T00:00:00+00:00</published><updated>2022-06-05T00:00:00+00:00</updated><id>https://jebbly.github.io/blog/2022/gsoc-introduction</id><content type="html" xml:base="https://jebbly.github.io/blog/2022/gsoc-introduction/"><![CDATA[<p>Welcome to the first post of my blog! This is something I’ve always kind of wanted to do but wasn’t sure where to start or what to post. Fortunately, participating in Google’s Summer of Code (GSoC) has finally given me the push that I needed to get going.</p> <p>This summer, I’ll be working with the Blender Foundation. I’ve been a long-time Blender user and it’s something that I’ve wanted to give back to for a long time (in fact, it’s part of the reason why I started learning C++). Part of GSoC with Blender also requires me to post weekly reports of my progress. I’ll be doing those summaries on the Blender wiki, but I wanted to keep a complementary blog, which will be on the more technical side, for 2 main reasons.</p> <p>Firstly, I want somewhere to keep track of my notes and my progress. Secondly, since this series is definitely going to be a sort of learning journey, I’m hoping that readers will be able to refer to it as a resource to get familiar with the Cycles codebase. It would be great if it helped new contributors get started.</p> <h2 id="the-project">The Project</h2> <p>The project I’m working on is to integrate Many Lights Sampling into Cycles X, which is the most recent version of Blender’s production renderer. I’ll be mentored by both Brecht Van Lommel and Lukas Stockner. If this project sounds familiar, that’s because past GSoC participants have already done work with this algorithm. This year, the goal is to complete the implementation and hopefully get it merged.</p> <p>Currently, I’ve been reading through PBRT’s chapters about multiple importance sampling (MIS) and direct light sampling. I’ve also checked out some of Blender’s source code related to sampling lights. The first step of implementing this algorithm is to get it working for point lights only, so I’ve created some Blender scenes with a single cube combined with 1, 2, 4, 8, 100, or 1000 point lights (no background light yet).</p> <h2 id="closing-thoughts">Closing Thoughts</h2> <p>Since this is my first time writing a blog, it definitely felt strange; I spent an unnecessarily long amount of time deciding how I wanted to express certain things. Hopefully, it’ll start to feel more natural once I write more posts.</p> <p>In my next post, I’m planning to elaborate on what I’ve learned so far about MIS and Blender’s source code. Hopefully I’ll also have the algorithm working with point lights so I can talk about that too!</p>]]></content><author><name></name></author><category term="gsoc-2022"/><category term="path-tracing"/><summary type="html"><![CDATA[A self-introduction and my plans for this series.]]></summary></entry></feed>